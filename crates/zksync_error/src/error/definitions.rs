//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(unused)]
#![allow(clippy::useless_format)]
#![allow(non_camel_case_types)]
use crate::documentation::Documented;
use crate::error::CustomErrorMessage;
use crate::error::ICustomError as _;
use crate::error::IError as _;
use crate::error::NamedError;
use strum_macros::AsRefStr;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(AnvilEnvironmentCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilEnvironment {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for AnvilEnvironment {}
impl NamedError for AnvilEnvironment {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilEnvironmentCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilEnvironment> for crate::ZksyncError {
    fn from(val: AnvilEnvironment) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for AnvilEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for AnvilEnvironment {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for AnvilEnvironment {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilEnvironment::GenericError { message }
    }
}
impl From<AnvilEnvironment> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilEnvironment) -> Self {
        crate::packed::pack(value)
    }
}
impl From<AnvilEnvironment> for crate::serialized::SerializedError {
    fn from(value: AnvilEnvironment) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilEnvironment {
    fn get_message(&self) -> String {
        match self {
            AnvilEnvironment::GenericError { message } => {
                format!("[anvil_zksync-env-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(AnvilGenericCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilGeneric {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for AnvilGeneric {}
impl NamedError for AnvilGeneric {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilGenericCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilGeneric> for crate::ZksyncError {
    fn from(val: AnvilGeneric) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for AnvilGeneric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for AnvilGeneric {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for AnvilGeneric {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilGeneric::GenericError { message }
    }
}
impl From<AnvilGeneric> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilGeneric) -> Self {
        crate::packed::pack(value)
    }
}
impl From<AnvilGeneric> for crate::serialized::SerializedError {
    fn from(value: AnvilGeneric) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilGeneric {
    fn get_message(&self) -> String {
        match self {
            AnvilGeneric::GenericError { message } => {
                format!("[anvil_zksync-gen-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HaltCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Halt {
    #[doc = "# Summary "]
    #[doc = "Account validation failed during execution."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the account validation step fails during the verification and execution of a transaction."]
    ValidationFailed {
        msg: String,
        data: String,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "Paymaster validation failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the paymaster validation process fails during transaction execution."]
    PaymasterValidationFailed {
        msg: String,
        data: String,
    } = 2u32,
    #[doc = "# Summary "]
    #[doc = "Pre-paymaster preparation step failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs during pre-transaction paymaster preparation if the paymaster input is too short (less than 4 bytes) or its selector is unsupported."]
    PrePaymasterPreparationFailed {
        msg: String,
        data: String,
    } = 3u32,
    #[doc = "# Summary "]
    #[doc = "Payment for the transaction failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the system fails to deduct the required fees for executing the transaction."]
    PayForTxFailed {
        msg: String,
        data: String,
    } = 4u32,
    #[doc = "# Summary "]
    #[doc = "Failed to register factory dependencies for L1 transactions."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the system is unable to mark the factory dependencies for an L1 transaction in the known code storage. For L1 transactions, factory dependencies must be recorded as known to ensure that all required code components are available. A failure here may indicate that the dependency data is missing or malformed."]
    FailedToMarkFactoryDependencies {
        msg: String,
        data: String,
    } = 5u32,
    #[doc = "# Summary "]
    #[doc = "Transaction fee deduction failed."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is raised when the funds transferred to the bootloader are insufficient compared to the required fee (calculated as gasLimit * gasPrice). This may occur when the payer (account or paymaster) does not send enough ETH or when fee parameters are misconfigured."]
    FailedToChargeFee {
        msg: String,
        data: String,
    } = 6u32,
    #[doc = "# Summary "]
    #[doc = "The sender address is not a valid account."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when a transaction is attempted from an address that has not been deployed as an account, meaning the `from` address is just a contract."]
    FromIsNotAnAccount = 7u32,
    #[doc = "# Summary "]
    #[doc = "An inner transaction error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Transaction reverted due to a contract call that failed during execution."]
    InnerTxError = 8u32,
    #[doc = "# Summary "]
    #[doc = "An unknown error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the system encounters an unspecified reason for halting."]
    Unknown {
        msg: String,
        data: String,
    } = 9u32,
    #[doc = "# Summary "]
    #[doc = "The bootloader encountered an unexpected state."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error can be triggered by various bootloader anomalies such as mismatched fee parameters (e.g., baseFee greater than maxFeePerGas), unaccepted pubdata price, failed system calls (like L1 messenger or System Context), or internal assertion failures."]
    UnexpectedVMBehavior {
        problem: String,
    } = 10u32,
    #[doc = "# Summary "]
    #[doc = "The bootloader has run out of gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the bootloader does not have enough gas to continue executing the transaction."]
    BootloaderOutOfGas = 11u32,
    #[doc = "# Summary "]
    #[doc = "The validation step ran out of gas."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Validation step of transaction execution exceeds the allocated gas limit."]
    ValidationOutOfGas = 12u32,
    #[doc = "# Summary "]
    #[doc = "The transaction's gas limit is excessively high."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the gas limit set for the transaction is too large for the server to handle."]
    TooBigGasLimit = 13u32,
    #[doc = "# Summary "]
    #[doc = "Insufficient gas for the bootloader to continue the transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The bootloader checks if it can supply the requested gas plus overhead. If the remaining gas is below this threshold, it reverts."]
    NotEnoughGasProvided = 14u32,
    #[doc = "# Summary "]
    #[doc = "The transaction exceeded the allowed number of storage invocations."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error occurs when the transaction makes too many missing invocations to memory, surpassing the allowed limit."]
    MissingInvocationLimitReached = 15u32,
    #[doc = "# Summary "]
    #[doc = "Unable to set L2 block information."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "System failed to set the necessary information for the L2 block during execution."]
    FailedToSetL2Block {
        msg: String,
    } = 16u32,
    #[doc = "# Summary "]
    #[doc = "Unable to append the transaction hash to the ongoing L2 block."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "The system context call to record this transaction in the current L2 block failed. Common causes include invalid or corrupted L2 block data, insufficient gas, or unforeseen internal errors in the system context."]
    FailedToAppendTransactionToL2Block {
        msg: String,
    } = 17u32,
    #[doc = "# Summary "]
    #[doc = "The virtual machine encountered a panic."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "VM experiences a critical failure and panic during transaction execution."]
    VMPanic = 18u32,
    #[doc = "# Summary "]
    #[doc = "Tracer aborted the transaction execution."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Custom tracer used during transaction execution decides to abort the process, typically due to specific conditions being met."]
    TracerCustom {
        msg: String,
    } = 19u32,
    #[doc = "# Summary "]
    #[doc = "Unable to publish compressed bytecodes."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "Emitted when the system fails to publish the compressed bytecodes during execution."]
    FailedToPublishCompressedBytecodes = 20u32,
    #[doc = "# Summary "]
    #[doc = "Block timestamp assertion failed during the transaction."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error often occurs if the transaction's timestamp is behind the last known block or conflicts with expected chronological order."]
    FailedBlockTimestampAssertion = 21u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for Halt {}
impl NamedError for Halt {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HaltCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Halt> for crate::ZksyncError {
    fn from(val: Halt) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Halt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Halt {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Halt {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Halt::GenericError { message }
    }
}
impl From<Halt> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Halt) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Halt> for crate::serialized::SerializedError {
    fn from(value: Halt) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Halt {
    fn get_message(&self) -> String {
        match self {
            Halt::ValidationFailed { msg, data } => {
                format!("[anvil_zksync-halt-1] Account validation error: {msg}: {data}")
            }
            Halt::PaymasterValidationFailed { msg, data } => {
                format!("[anvil_zksync-halt-2] Paymaster validation error: {msg}: {data}.")
            }
            Halt::PrePaymasterPreparationFailed { msg, data } => {
                format!("[anvil_zksync-halt-3] Pre-paymaster preparation error: {msg}: {data}")
            }
            Halt::PayForTxFailed { msg, data } => {
                format!("[anvil_zksync-halt-4] Failed to pay for the transaction: {msg}: {data}")
            }
            Halt::FailedToMarkFactoryDependencies { msg, data } => {
                format!("[anvil_zksync-halt-5] Failed to mark factory dependencies: {msg}: {data}")
            }
            Halt::FailedToChargeFee { msg, data } => {
                format!("[anvil_zksync-halt-6] Failed to charge fee: {msg}: {data}")
            }
            Halt::FromIsNotAnAccount => {
                format!("[anvil_zksync-halt-7] Sender is not an account")
            }
            Halt::InnerTxError => {
                format!("[anvil_zksync-halt-8] Bootloader-based tx failed")
            }
            Halt::Unknown { msg, data } => {
                format!("[anvil_zksync-halt-9] Unknown reason: {msg}: {data}")
            }
            Halt::UnexpectedVMBehavior { problem } => {
                format ! ("[anvil_zksync-halt-10] Virtual machine entered unexpected state. Error description: {problem}")
            }
            Halt::BootloaderOutOfGas => {
                format!("[anvil_zksync-halt-11] Bootloader out of gas")
            }
            Halt::ValidationOutOfGas => {
                format!("[anvil_zksync-halt-12] Validation run out of gas")
            }
            Halt::TooBigGasLimit => {
                format ! ("[anvil_zksync-halt-13] Transaction has a too big ergs limit and will not be executed by the server")
            }
            Halt::NotEnoughGasProvided => {
                format ! ("[anvil_zksync-halt-14] Bootloader does not have enough gas to proceed with the transaction.")
            }
            Halt::MissingInvocationLimitReached => {
                format!("[anvil_zksync-halt-15] Transaction produced too much storage accesses.")
            }
            Halt::FailedToSetL2Block { msg } => {
                format!(
                    "[anvil_zksync-halt-16] Failed to set information about the L2 block: {msg}"
                )
            }
            Halt::FailedToAppendTransactionToL2Block { msg } => {
                format ! ("[anvil_zksync-halt-17] Failed to append the transaction to the current L2 block: {msg}")
            }
            Halt::VMPanic => {
                format!("[anvil_zksync-halt-18] VM panicked")
            }
            Halt::TracerCustom { msg } => {
                format!("[anvil_zksync-halt-19] Tracer aborted execution: {msg}")
            }
            Halt::FailedToPublishCompressedBytecodes => {
                format!("[anvil_zksync-halt-20] Failed to publish compressed bytecodes")
            }
            Halt::FailedBlockTimestampAssertion => {
                format!("[anvil_zksync-halt-21] Transaction failed `block.timestamp` assertion")
            }
            Halt::GenericError { message } => {
                format!("[anvil_zksync-halt-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(RevertCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Revert {
    #[doc = "# Summary "]
    #[doc = "Execution reverted due to a failure."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error indicates that the transaction execution was reverted."]
    General {
        msg: String,
        data: Vec<u8>,
    } = 1u32,
    #[doc = "# Summary "]
    #[doc = "An inner transaction error occurred."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when an inner transaction within the VM fails, typically related to bootloader execution."]
    InnerTxError = 2u32,
    #[doc = "# Summary "]
    #[doc = "A generic VM error."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error indicates a generic failure within the VM, without specific details."]
    VmError = 3u32,
    #[doc = "# Summary "]
    #[doc = "An unknown VM revert reason was encountered."]
    #[doc = ""]
    #[doc = "# Description"]
    #[doc = "This error is emitted when the VM encounters a revert reason that is not recognized. In most cases, this error may also indicate that the transaction exhausted all the gas allocated for its execution."]
    Unknown {
        function_selector: String,
        data: String,
    } = 4u32,
    GenericError {
        message: String,
    } = 0u32,
}
impl std::error::Error for Revert {}
impl NamedError for Revert {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for RevertCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Revert> for crate::ZksyncError {
    fn from(val: Revert) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Revert {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Revert {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Revert {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Revert::GenericError { message }
    }
}
impl From<Revert> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Revert) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Revert> for crate::serialized::SerializedError {
    fn from(value: Revert) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Revert {
    fn get_message(&self) -> String {
        match self {
            Revert::General { msg, data } => {
                format!("[anvil_zksync-revert-1] General revert error: {msg}")
            }
            Revert::InnerTxError => {
                format!("[anvil_zksync-revert-2] Bootloader-based transaction failed.")
            }
            Revert::VmError => {
                format!("[anvil_zksync-revert-3] VM Error")
            }
            Revert::Unknown {
                function_selector,
                data,
            } => {
                format ! ("[anvil_zksync-revert-4] Unknown VM revert reason: function_selector={function_selector}, data={data}")
            }
            Revert::GenericError { message } => {
                format!("[anvil_zksync-revert-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for Ethereum VM (EVM)."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(LLVM_EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_EVM {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for LLVM_EVM {}
impl NamedError for LLVM_EVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<LLVM_EVM> for crate::ZksyncError {
    fn from(val: LLVM_EVM) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for LLVM_EVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for LLVM_EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for LLVM_EVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_EVM::GenericError { message }
    }
}
impl From<LLVM_EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_EVM) -> Self {
        crate::packed::pack(value)
    }
}
impl From<LLVM_EVM> for crate::serialized::SerializedError {
    fn from(value: LLVM_EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for LLVM_EVM {
    fn get_message(&self) -> String {
        match self {
            LLVM_EVM::GenericError { message } => {
                format!("[compiler-llvm+evm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(LLVM_EraCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_Era {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for LLVM_Era {}
impl NamedError for LLVM_Era {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EraCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<LLVM_Era> for crate::ZksyncError {
    fn from(val: LLVM_Era) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for LLVM_Era {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for LLVM_Era {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for LLVM_Era {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_Era::GenericError { message }
    }
}
impl From<LLVM_Era> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_Era) -> Self {
        crate::packed::pack(value)
    }
}
impl From<LLVM_Era> for crate::serialized::SerializedError {
    fn from(value: LLVM_Era) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for LLVM_Era {
    fn get_message(&self) -> String {
        match self {
            LLVM_Era::GenericError { message } => {
                format!("[compiler-llvm+era-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the official Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Solc {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Solc {}
impl NamedError for Solc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Solc> for crate::ZksyncError {
    fn from(val: Solc) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Solc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Solc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Solc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Solc::GenericError { message }
    }
}
impl From<Solc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Solc) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Solc> for crate::serialized::SerializedError {
    fn from(value: Solc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Solc {
    fn get_message(&self) -> String {
        match self {
            Solc::GenericError { message } => {
                format!("[compiler-solc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync fork of Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SolcForkCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum SolcFork {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for SolcFork {}
impl NamedError for SolcFork {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcForkCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<SolcFork> for crate::ZksyncError {
    fn from(val: SolcFork) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for SolcFork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for SolcFork {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for SolcFork {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        SolcFork::GenericError { message }
    }
}
impl From<SolcFork> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SolcFork) -> Self {
        crate::packed::pack(value)
    }
}
impl From<SolcFork> for crate::serialized::SerializedError {
    fn from(value: SolcFork) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for SolcFork {
    fn get_message(&self) -> String {
        match self {
            SolcFork::GenericError { message } => {
                format!("[compiler-solc+fork-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Solidity compiler for EraVM and EVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ZksolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zksolc {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Zksolc {}
impl NamedError for Zksolc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZksolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Zksolc> for crate::ZksyncError {
    fn from(val: Zksolc) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Zksolc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Zksolc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Zksolc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zksolc::GenericError { message }
    }
}
impl From<Zksolc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zksolc) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Zksolc> for crate::serialized::SerializedError {
    fn from(value: Zksolc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Zksolc {
    fn get_message(&self) -> String {
        match self {
            Zksolc::GenericError { message } => {
                format!("[compiler-zksolc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Vyper compiler for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ZkvyperCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zkvyper {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Zkvyper {}
impl NamedError for Zkvyper {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZkvyperCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Zkvyper> for crate::ZksyncError {
    fn from(val: Zkvyper) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Zkvyper {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Zkvyper {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Zkvyper {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zkvyper::GenericError { message }
    }
}
impl From<Zkvyper> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zkvyper) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Zkvyper> for crate::serialized::SerializedError {
    fn from(value: Zkvyper) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Zkvyper {
    fn get_message(&self) -> String {
        match self {
            Zkvyper::GenericError { message } => {
                format!("[compiler-zkvyper-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the web3 API."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(APICode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum API {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for API {}
impl NamedError for API {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for APICode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<API> for crate::ZksyncError {
    fn from(val: API) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for API {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for API {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for API {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        API::GenericError { message }
    }
}
impl From<API> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: API) -> Self {
        crate::packed::pack(value)
    }
}
impl From<API> for crate::serialized::SerializedError {
    fn from(value: API) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for API {
    fn get_message(&self) -> String {
        match self {
            API::GenericError { message } => {
                format!("[core-api-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in EraVM virtual machine executing contracts."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(EraVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum EraVM {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for EraVM {}
impl NamedError for EraVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for EraVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<EraVM> for crate::ZksyncError {
    fn from(val: EraVM) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for EraVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for EraVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for EraVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        EraVM::GenericError { message }
    }
}
impl From<EraVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EraVM) -> Self {
        crate::packed::pack(value)
    }
}
impl From<EraVM> for crate::serialized::SerializedError {
    fn from(value: EraVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for EraVM {
    fn get_message(&self) -> String {
        match self {
            EraVM::GenericError { message } => {
                format!("[core-eravm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the contract execution environment, bootloader, etc."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ExecutionPlatformCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum ExecutionPlatform {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for ExecutionPlatform {}
impl NamedError for ExecutionPlatform {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ExecutionPlatformCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<ExecutionPlatform> for crate::ZksyncError {
    fn from(val: ExecutionPlatform) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for ExecutionPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for ExecutionPlatform {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for ExecutionPlatform {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        ExecutionPlatform::GenericError { message }
    }
}
impl From<ExecutionPlatform> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: ExecutionPlatform) -> Self {
        crate::packed::pack(value)
    }
}
impl From<ExecutionPlatform> for crate::serialized::SerializedError {
    fn from(value: ExecutionPlatform) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for ExecutionPlatform {
    fn get_message(&self) -> String {
        match self {
            ExecutionPlatform::GenericError { message } => {
                format!("[core-exec-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the sequencer node"]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SequencerCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Sequencer {
    GenericSequencerError { message: String } = 1u32,
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Sequencer {}
impl NamedError for Sequencer {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SequencerCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Sequencer> for crate::ZksyncError {
    fn from(val: Sequencer) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Sequencer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Sequencer {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Sequencer {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Sequencer::GenericError { message }
    }
}
impl From<Sequencer> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Sequencer) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Sequencer> for crate::serialized::SerializedError {
    fn from(value: Sequencer) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Sequencer {
    fn get_message(&self) -> String {
        match self {
            Sequencer::GenericSequencerError { message } => {
                format!("[core-seq-1] Generic error: {message}")
            }
            Sequencer::GenericError { message } => {
                format!("[core-seq-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Foundry implementation."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(FoundryUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryUpstream {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for FoundryUpstream {}
impl NamedError for FoundryUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<FoundryUpstream> for crate::ZksyncError {
    fn from(val: FoundryUpstream) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for FoundryUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for FoundryUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for FoundryUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryUpstream::GenericError { message }
    }
}
impl From<FoundryUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryUpstream) -> Self {
        crate::packed::pack(value)
    }
}
impl From<FoundryUpstream> for crate::serialized::SerializedError {
    fn from(value: FoundryUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for FoundryUpstream {
    fn get_message(&self) -> String {
        match self {
            FoundryUpstream::GenericError { message } => {
                format!("[foundry-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for Foundry."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(FoundryZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryZksync {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for FoundryZksync {}
impl NamedError for FoundryZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<FoundryZksync> for crate::ZksyncError {
    fn from(val: FoundryZksync) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for FoundryZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for FoundryZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for FoundryZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryZksync::GenericError { message }
    }
}
impl From<FoundryZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryZksync) -> Self {
        crate::packed::pack(value)
    }
}
impl From<FoundryZksync> for crate::serialized::SerializedError {
    fn from(value: FoundryZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for FoundryZksync {
    fn get_message(&self) -> String {
        match self {
            FoundryZksync::GenericError { message } => {
                format!("[foundry-zksync-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Hardhat implementation."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HardhatUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatUpstream {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for HardhatUpstream {}
impl NamedError for HardhatUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<HardhatUpstream> for crate::ZksyncError {
    fn from(val: HardhatUpstream) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for HardhatUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for HardhatUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for HardhatUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatUpstream::GenericError { message }
    }
}
impl From<HardhatUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatUpstream) -> Self {
        crate::packed::pack(value)
    }
}
impl From<HardhatUpstream> for crate::serialized::SerializedError {
    fn from(value: HardhatUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for HardhatUpstream {
    fn get_message(&self) -> String {
        match self {
            HardhatUpstream::GenericError { message } => {
                format!("[hardhat-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for HardHat."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HardhatZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatZksync {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for HardhatZksync {}
impl NamedError for HardhatZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<HardhatZksync> for crate::ZksyncError {
    fn from(val: HardhatZksync) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for HardhatZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for HardhatZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for HardhatZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatZksync::GenericError { message }
    }
}
impl From<HardhatZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatZksync) -> Self {
        crate::packed::pack(value)
    }
}
impl From<HardhatZksync> for crate::serialized::SerializedError {
    fn from(value: HardhatZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for HardhatZksync {
    fn get_message(&self) -> String {
        match self {
            HardhatZksync::GenericError { message } => {
                format!("[hardhat-zksync-0] Generic error: {message}")
            }
        }
    }
}
