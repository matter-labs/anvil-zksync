
//!
//! AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//!


#![allow(unused)]
#![allow(non_camel_case_types)]

use crate::documentation::Documented;
use crate::error::CustomErrorMessage;
use crate::error::NamedError;
use crate::error::ICustomError as _;
use crate::error::IError as _;
use strum_macros::AsRefStr;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(AnvilEnvironmentCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilEnvironment {
   /// # Short description
   /// Unable to access log file.
   ///
   /// # Description
   /// Anvil was unable to open the log file for writing.
   LogFileAccessError {
      log_filename : String,
      wrapped_error : String,
   } = 1, 
   UnsupportedMethodError  = 2, 
   Web3Error {
      inner : Box<API>,
   } = 3, 
   GenericError {
      message : String,
   } = 0, 
   
} // end of AnvilEnvironment


impl std::error::Error for AnvilEnvironment {}

impl NamedError for AnvilEnvironment {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilEnvironmentCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<AnvilEnvironment> for crate::ZksyncError {
    fn from(val: AnvilEnvironment) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for AnvilEnvironment {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilEnvironment::GenericError { message }
    }
}


impl Documented for AnvilEnvironment {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for AnvilEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for AnvilEnvironment {
    fn get_message(&self) -> String {
        match self {
         AnvilEnvironment::LogFileAccessError { 
            log_filename,
            wrapped_error,
         }
          => { format!("[anvil-env-1] Unable to access log file: {log_filename}") },
         AnvilEnvironment::UnsupportedMethodError { 
         }
          => { format!("[anvil-env-2] Unsupported method.") },
         AnvilEnvironment::Web3Error { 
            inner,
         }
          => { format!("[anvil-env-3] Web3Error: {inner}.") },
         AnvilEnvironment::GenericError { 
            message,
         }
          => { format!("[anvil-env-0] Generic error: {message}") },
      }
   }
}

impl From<AnvilEnvironment> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilEnvironment) -> Self {
        crate::packed::pack(value)
    }
}

impl From<AnvilEnvironment> for crate::serialized::SerializedError {
    fn from(value: AnvilEnvironment) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(StateLoaderCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum StateLoader {
   /// # Short description
   /// It is not allowed to load a state overriding the existing node state. If you have a use case for that, please create an issue.
   ///
   /// # Description
   /// It is not allowed to load a state overriding the existing node state.
   LoadingStateOverExistingStateError  = 1, 
   /// # Short description
   /// It is not allowed to load a state without any blocks in it.
   ///
   /// # Description
   /// It is not allowed to load a state without any blocks in it.
   LoadEmptyStateError  = 2, 
   StateDecompressionError {
      details : String,
   } = 3, 
   StateDeserializationError {
      details : String,
   } = 4, 
   UnknownStateVersionError {
      version : u32,
   } = 5, 
   LoadStateError {
      path : String,
      reason : String,
   } = 6, 
   GenericError {
      message : String,
   } = 0, 
   
} // end of StateLoader


impl std::error::Error for StateLoader {}

impl NamedError for StateLoader {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for StateLoaderCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<StateLoader> for crate::ZksyncError {
    fn from(val: StateLoader) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for StateLoader {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        StateLoader::GenericError { message }
    }
}


impl Documented for StateLoader {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for StateLoader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for StateLoader {
    fn get_message(&self) -> String {
        match self {
         StateLoader::LoadingStateOverExistingStateError { 
         }
          => { format!("[anvil-state-1] Loading state into a node with existing state is not allowed.") },
         StateLoader::LoadEmptyStateError { 
         }
          => { format!("[anvil-state-2] Loading a state without blocks is not allowed.") },
         StateLoader::StateDecompressionError { 
            details,
         }
          => { format!("[anvil-state-3] Failed to decompress state: {details}.") },
         StateLoader::StateDeserializationError { 
            details,
         }
          => { format!("[anvil-state-4] Failed to deserialize state: {details}") },
         StateLoader::UnknownStateVersionError { 
            version,
         }
          => { format!("[anvil-state-5] Unknown version of the state: {version}.") },
         StateLoader::LoadStateError { 
            path,
            reason,
         }
          => { format!("[anvil-state-6] Error while attempting to access the state located at `{path}`. Reason: {reason}.") },
         StateLoader::GenericError { 
            message,
         }
          => { format!("[anvil-state-0] Generic error: {message}") },
      }
   }
}

impl From<StateLoader> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: StateLoader) -> Self {
        crate::packed::pack(value)
    }
}

impl From<StateLoader> for crate::serialized::SerializedError {
    fn from(value: StateLoader) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the compiler backend for Ethereum VM (EVM).

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(LLVM_EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_EVM {
   GenericError {
      message : String,
   } = 0, 
   
} // end of LLVM_EVM


impl std::error::Error for LLVM_EVM {}

impl NamedError for LLVM_EVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<LLVM_EVM> for crate::ZksyncError {
    fn from(val: LLVM_EVM) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for LLVM_EVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_EVM::GenericError { message }
    }
}


impl Documented for LLVM_EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for LLVM_EVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for LLVM_EVM {
    fn get_message(&self) -> String {
        match self {
         LLVM_EVM::GenericError { 
            message,
         }
          => { format!("[compiler-llvm+evm-0] Generic error: {message}") },
      }
   }
}

impl From<LLVM_EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_EVM) -> Self {
        crate::packed::pack(value)
    }
}

impl From<LLVM_EVM> for crate::serialized::SerializedError {
    fn from(value: LLVM_EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the compiler backend for EraVM.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(LLVM_EraCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_Era {
   GenericError {
      message : String,
   } = 0, 
   
} // end of LLVM_Era


impl std::error::Error for LLVM_Era {}

impl NamedError for LLVM_Era {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EraCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<LLVM_Era> for crate::ZksyncError {
    fn from(val: LLVM_Era) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for LLVM_Era {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_Era::GenericError { message }
    }
}


impl Documented for LLVM_Era {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for LLVM_Era {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for LLVM_Era {
    fn get_message(&self) -> String {
        match self {
         LLVM_Era::GenericError { 
            message,
         }
          => { format!("[compiler-llvm+era-0] Generic error: {message}") },
      }
   }
}

impl From<LLVM_Era> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_Era) -> Self {
        crate::packed::pack(value)
    }
}

impl From<LLVM_Era> for crate::serialized::SerializedError {
    fn from(value: LLVM_Era) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the official Solidity compiler.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(SolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Solc {
   GenericError {
      message : String,
   } = 0, 
   
} // end of Solc


impl std::error::Error for Solc {}

impl NamedError for Solc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Solc> for crate::ZksyncError {
    fn from(val: Solc) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for Solc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Solc::GenericError { message }
    }
}


impl Documented for Solc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Solc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Solc {
    fn get_message(&self) -> String {
        match self {
         Solc::GenericError { 
            message,
         }
          => { format!("[compiler-solc-0] Generic error: {message}") },
      }
   }
}

impl From<Solc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Solc) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Solc> for crate::serialized::SerializedError {
    fn from(value: Solc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync fork of Solidity compiler.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(SolcForkCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum SolcFork {
   GenericError {
      message : String,
   } = 0, 
   
} // end of SolcFork


impl std::error::Error for SolcFork {}

impl NamedError for SolcFork {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcForkCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<SolcFork> for crate::ZksyncError {
    fn from(val: SolcFork) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for SolcFork {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        SolcFork::GenericError { message }
    }
}


impl Documented for SolcFork {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for SolcFork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for SolcFork {
    fn get_message(&self) -> String {
        match self {
         SolcFork::GenericError { 
            message,
         }
          => { format!("[compiler-solc+fork-0] Generic error: {message}") },
      }
   }
}

impl From<SolcFork> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SolcFork) -> Self {
        crate::packed::pack(value)
    }
}

impl From<SolcFork> for crate::serialized::SerializedError {
    fn from(value: SolcFork) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync Solidity compiler for EraVM and EVM.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(ZksolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zksolc {
   GenericError {
      message : String,
   } = 0, 
   
} // end of Zksolc


impl std::error::Error for Zksolc {}

impl NamedError for Zksolc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZksolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Zksolc> for crate::ZksyncError {
    fn from(val: Zksolc) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for Zksolc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zksolc::GenericError { message }
    }
}


impl Documented for Zksolc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Zksolc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Zksolc {
    fn get_message(&self) -> String {
        match self {
         Zksolc::GenericError { 
            message,
         }
          => { format!("[compiler-zksolc-0] Generic error: {message}") },
      }
   }
}

impl From<Zksolc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zksolc) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Zksolc> for crate::serialized::SerializedError {
    fn from(value: Zksolc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync Vyper compiler for EraVM.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(ZkvyperCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zkvyper {
   GenericError {
      message : String,
   } = 0, 
   
} // end of Zkvyper


impl std::error::Error for Zkvyper {}

impl NamedError for Zkvyper {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZkvyperCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Zkvyper> for crate::ZksyncError {
    fn from(val: Zkvyper) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for Zkvyper {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zkvyper::GenericError { message }
    }
}


impl Documented for Zkvyper {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Zkvyper {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Zkvyper {
    fn get_message(&self) -> String {
        match self {
         Zkvyper::GenericError { 
            message,
         }
          => { format!("[compiler-zkvyper-0] Generic error: {message}") },
      }
   }
}

impl From<Zkvyper> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zkvyper) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Zkvyper> for crate::serialized::SerializedError {
    fn from(value: Zkvyper) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the web3 API.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(APICode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum API {
   GenericError {
      message : String,
   } = 0, 
   
} // end of API


impl std::error::Error for API {}

impl NamedError for API {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for APICode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<API> for crate::ZksyncError {
    fn from(val: API) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for API {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        API::GenericError { message }
    }
}


impl Documented for API {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for API {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for API {
    fn get_message(&self) -> String {
        match self {
         API::GenericError { 
            message,
         }
          => { format!("[core-api-0] Generic error: {message}") },
      }
   }
}

impl From<API> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: API) -> Self {
        crate::packed::pack(value)
    }
}

impl From<API> for crate::serialized::SerializedError {
    fn from(value: API) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors in EraVM virtual machine executing contracts.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(EraVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum EraVM {
   GenericError {
      message : String,
   } = 0, 
   
} // end of EraVM


impl std::error::Error for EraVM {}

impl NamedError for EraVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for EraVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<EraVM> for crate::ZksyncError {
    fn from(val: EraVM) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for EraVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        EraVM::GenericError { message }
    }
}


impl Documented for EraVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for EraVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for EraVM {
    fn get_message(&self) -> String {
        match self {
         EraVM::GenericError { 
            message,
         }
          => { format!("[core-eravm-0] Generic error: {message}") },
      }
   }
}

impl From<EraVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EraVM) -> Self {
        crate::packed::pack(value)
    }
}

impl From<EraVM> for crate::serialized::SerializedError {
    fn from(value: EraVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors in the contract execution environment, bootloader, etc.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(ExecutionPlatformCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum ExecutionPlatform {
   GenericError {
      message : String,
   } = 0, 
   
} // end of ExecutionPlatform


impl std::error::Error for ExecutionPlatform {}

impl NamedError for ExecutionPlatform {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ExecutionPlatformCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<ExecutionPlatform> for crate::ZksyncError {
    fn from(val: ExecutionPlatform) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for ExecutionPlatform {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        ExecutionPlatform::GenericError { message }
    }
}


impl Documented for ExecutionPlatform {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for ExecutionPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for ExecutionPlatform {
    fn get_message(&self) -> String {
        match self {
         ExecutionPlatform::GenericError { 
            message,
         }
          => { format!("[core-exec-0] Generic error: {message}") },
      }
   }
}

impl From<ExecutionPlatform> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: ExecutionPlatform) -> Self {
        crate::packed::pack(value)
    }
}

impl From<ExecutionPlatform> for crate::serialized::SerializedError {
    fn from(value: ExecutionPlatform) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors in the sequencer node

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(SequencerCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Sequencer {
   GenericSequencerError {
      message : String,
   } = 1, 
   GenericError {
      message : String,
   } = 0, 
   
} // end of Sequencer


impl std::error::Error for Sequencer {}

impl NamedError for Sequencer {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SequencerCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Sequencer> for crate::ZksyncError {
    fn from(val: Sequencer) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for Sequencer {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Sequencer::GenericError { message }
    }
}


impl Documented for Sequencer {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Sequencer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Sequencer {
    fn get_message(&self) -> String {
        match self {
         Sequencer::GenericSequencerError { 
            message,
         }
          => { format!("[core-seq-1] Generic error: {message}") },
         Sequencer::GenericError { 
            message,
         }
          => { format!("[core-seq-0] Generic error: {message}") },
      }
   }
}

impl From<Sequencer> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Sequencer) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Sequencer> for crate::serialized::SerializedError {
    fn from(value: Sequencer) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the upstream Foundry implementation.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(FoundryUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryUpstream {
   GenericError {
      message : String,
   } = 0, 
   
} // end of FoundryUpstream


impl std::error::Error for FoundryUpstream {}

impl NamedError for FoundryUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<FoundryUpstream> for crate::ZksyncError {
    fn from(val: FoundryUpstream) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for FoundryUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryUpstream::GenericError { message }
    }
}


impl Documented for FoundryUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for FoundryUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for FoundryUpstream {
    fn get_message(&self) -> String {
        match self {
         FoundryUpstream::GenericError { 
            message,
         }
          => { format!("[foundry-upstream-0] Generic error: {message}") },
      }
   }
}

impl From<FoundryUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryUpstream) -> Self {
        crate::packed::pack(value)
    }
}

impl From<FoundryUpstream> for crate::serialized::SerializedError {
    fn from(value: FoundryUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync codebase for Foundry.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(FoundryZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryZksync {
   GenericError {
      message : String,
   } = 0, 
   
} // end of FoundryZksync


impl std::error::Error for FoundryZksync {}

impl NamedError for FoundryZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<FoundryZksync> for crate::ZksyncError {
    fn from(val: FoundryZksync) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for FoundryZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryZksync::GenericError { message }
    }
}


impl Documented for FoundryZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for FoundryZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for FoundryZksync {
    fn get_message(&self) -> String {
        match self {
         FoundryZksync::GenericError { 
            message,
         }
          => { format!("[foundry-zksync-0] Generic error: {message}") },
      }
   }
}

impl From<FoundryZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryZksync) -> Self {
        crate::packed::pack(value)
    }
}

impl From<FoundryZksync> for crate::serialized::SerializedError {
    fn from(value: FoundryZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the upstream Hardhat implementation.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(HardhatUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatUpstream {
   GenericError {
      message : String,
   } = 0, 
   
} // end of HardhatUpstream


impl std::error::Error for HardhatUpstream {}

impl NamedError for HardhatUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<HardhatUpstream> for crate::ZksyncError {
    fn from(val: HardhatUpstream) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for HardhatUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatUpstream::GenericError { message }
    }
}


impl Documented for HardhatUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for HardhatUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for HardhatUpstream {
    fn get_message(&self) -> String {
        match self {
         HardhatUpstream::GenericError { 
            message,
         }
          => { format!("[hardhat-upstream-0] Generic error: {message}") },
      }
   }
}

impl From<HardhatUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatUpstream) -> Self {
        crate::packed::pack(value)
    }
}

impl From<HardhatUpstream> for crate::serialized::SerializedError {
    fn from(value: HardhatUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync codebase for HardHat.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(HardhatZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatZksync {
   GenericError {
      message : String,
   } = 0, 
   
} // end of HardhatZksync


impl std::error::Error for HardhatZksync {}

impl NamedError for HardhatZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<HardhatZksync> for crate::ZksyncError {
    fn from(val: HardhatZksync) -> Self {
        val.to_unified()
    }
}


impl From<anyhow::Error> for HardhatZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatZksync::GenericError { message }
    }
}


impl Documented for HardhatZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for HardhatZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for HardhatZksync {
    fn get_message(&self) -> String {
        match self {
         HardhatZksync::GenericError { 
            message,
         }
          => { format!("[hardhat-zksync-0] Generic error: {message}") },
      }
   }
}

impl From<HardhatZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatZksync) -> Self {
        crate::packed::pack(value)
    }
}

impl From<HardhatZksync> for crate::serialized::SerializedError {
    fn from(value: HardhatZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
