
//!
//! AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//!


#![allow(unused)]
#![allow(non_camel_case_types)]

use crate::documentation::Documented;
use crate::error::CustomErrorMessage;
use crate::error::NamedError;
use crate::error::ICustomError as _;
use crate::error::IError as _;
use strum_macros::AsRefStr;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(HaltCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Halt {
   /// # Short description
   /// Account validation failed during execution.
   ///
   /// # Description
   /// This error occurs when the account validation step fails during the verification and execution of a transaction.
   ValidationFailed {
      msg : String,
      data : String,
   } = 1, 
   /// # Short description
   /// Paymaster validation failed.
   ///
   /// # Description
   /// This error is emitted when the paymaster validation process fails during transaction execution.
   PaymasterValidationFailed {
      msg : String,
      data : String,
   } = 2, 
   /// # Short description
   /// Pre-paymaster preparation step failed.
   ///
   /// # Description
   /// This error occurs when the system fails to prepare the paymaster before executing a transaction.
   PrePaymasterPreparationFailed {
      msg : String,
      data : String,
   } = 3, 
   /// # Short description
   /// Payment for the transaction failed.
   ///
   /// # Description
   /// This error is emitted when the system fails to deduct the required fees for executing the transaction.
   PayForTxFailed {
      msg : String,
      data : String,
   } = 4, 
   /// # Short description
   /// Failed to mark factory dependencies during execution.
   ///
   /// # Description
   /// This error occurs when the system cannot mark the necessary factory dependencies required for the transaction.
   FailedToMarkFactoryDependencies {
      msg : String,
      data : String,
   } = 5, 
   /// # Short description
   /// Charging the transaction fee failed.
   ///
   /// # Description
   /// This error is emitted when the system cannot deduct the necessary fee for the transaction.
   FailedToChargeFee {
      msg : String,
      data : String,
   } = 6, 
   /// # Short description
   /// The sender address is not a valid account.
   ///
   /// # Description
   /// This error occurs when a transaction is attempted from an address that has not been deployed as an account, meaning the `from` address is just a contract.
   FromIsNotAnAccount  = 7, 
   /// # Short description
   /// An inner transaction error occurred.
   ///
   /// # Description
   /// Transaction reverted due to a contract call that failed during execution.
   InnerTxError  = 8, 
   /// # Short description
   /// An unknown error occurred.
   ///
   /// # Description
   /// This error is emitted when the system encounters an unspecified reason for halting.
   Unknown {
      msg : String,
      data : String,
   } = 9, 
   /// # Short description
   /// The virtual machine encountered an unexpected state.
   ///
   /// # Description
   /// VM entered an unforeseen state during transaction execution.
   UnexpectedVMBehavior {
      problem : String,
   } = 10, 
   /// # Short description
   /// The bootloader has run out of gas.
   ///
   /// # Description
   /// This error occurs when the bootloader does not have enough gas to continue executing the transaction.
   BootloaderOutOfGas  = 11, 
   /// # Short description
   /// The validation step ran out of gas.
   ///
   /// # Description
   /// Validation phase of transaction execution exceeds the allocated gas limit.
   ValidationOutOfGas  = 12, 
   /// # Short description
   /// The transaction's gas limit is excessively high.
   ///
   /// # Description
   /// This error occurs when the gas limit set for the transaction is too large for the server to handle.
   TooBigGasLimit  = 13, 
   /// # Short description
   /// Insufficient gas provided to initiate the transaction.
   ///
   /// # Description
   /// Bootloader lacks the necessary gas to begin executing the transaction.
   NotEnoughGasProvided  = 14, 
   /// # Short description
   /// The transaction exceeded the allowed number of storage invocations.
   ///
   /// # Description
   /// This error occurs when the transaction makes too many missing invocations to memory, surpassing the allowed limit.
   MissingInvocationLimitReached  = 15, 
   /// # Short description
   /// Unable to set L2 block information.
   ///
   /// # Description
   /// System failed to set the necessary information for the L2 block during transaction execution.
   FailedToSetL2Block {
      msg : String,
   } = 16, 
   /// # Short description
   /// Failed to add the transaction to the L2 block.
   ///
   /// # Description
   /// System cannot append the transaction to the ongoing L2 block, possibly due to data inconsistencies or internal errors.
   FailedToAppendTransactionToL2Block {
      msg : String,
   } = 17, 
   /// # Short description
   /// The virtual machine encountered a panic.
   ///
   /// # Description
   /// VM experiences a critical failure and panic during transaction execution.
   VMPanic  = 18, 
   /// # Short description
   /// Tracer aborted the transaction execution.
   ///
   /// # Description
   /// Custom tracer used during transaction execution decides to abort the process, typically due to specific conditions being met.
   TracerCustom {
      msg : String,
   } = 19, 
   /// # Short description
   /// Unable to publish compressed bytecodes.
   ///
   /// # Description
   /// Emitted when the system fails to publish the compressed bytecodes during transaction execution.
   FailedToPublishCompressedBytecodes  = 20, 
   /// # Short description
   /// Block timestamp assertion failed during the transaction.
   ///
   /// # Description
   /// This error occurs when the transaction's execution fails to satisfy the `block.timestamp` assertion, indicating a discrepancy in the expected timestamp.
   FailedBlockTimestampAssertion  = 21, 
   GenericError {
      message : String,
   } = 0, 
   
} // end of Halt


impl std::error::Error for Halt {}

impl NamedError for Halt {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HaltCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Halt> for crate::ZksyncError {
    fn from(val: Halt) -> Self {
        val.to_unified()
    }
}


impl Documented for Halt {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Halt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Halt {
    fn get_message(&self) -> String {
        match self {
         Halt::ValidationFailed { 
            msg,
            data,
         }
          => { format!("[anvil-halt-1] Account validation error: {msg}: {data}") },
         Halt::PaymasterValidationFailed { 
            msg,
            data,
         }
          => { format!("[anvil-halt-2] Paymaster validation error: {msg}: {data}.") },
         Halt::PrePaymasterPreparationFailed { 
            msg,
            data,
         }
          => { format!("[anvil-halt-3] Pre-paymaster preparation error: {msg}: {data}") },
         Halt::PayForTxFailed { 
            msg,
            data,
         }
          => { format!("[anvil-halt-4] Failed to pay for the transaction: {msg}: {data}") },
         Halt::FailedToMarkFactoryDependencies { 
            msg,
            data,
         }
          => { format!("[anvil-halt-5] Failed to mark factory dependencies: {msg}: {data}") },
         Halt::FailedToChargeFee { 
            msg,
            data,
         }
          => { format!("[anvil-halt-6] Failed to charge fee: {msg}: {data}") },
         Halt::FromIsNotAnAccount { 
         }
          => { format!("[anvil-halt-7] Sender is not an account") },
         Halt::InnerTxError { 
         }
          => { format!("[anvil-halt-8] Bootloader-based tx failed") },
         Halt::Unknown { 
            msg,
            data,
         }
          => { format!("[anvil-halt-9] Unknown reason: {msg}: {data}") },
         Halt::UnexpectedVMBehavior { 
            problem,
         }
          => { format!("[anvil-halt-10] virtual machine entered unexpected state. Error description: {problem}") },
         Halt::BootloaderOutOfGas { 
         }
          => { format!("[anvil-halt-11] Bootloader out of gas") },
         Halt::ValidationOutOfGas { 
         }
          => { format!("[anvil-halt-12] Validation run out of gas") },
         Halt::TooBigGasLimit { 
         }
          => { format!("[anvil-halt-13] Transaction has a too big ergs limit and will not be executed by the server") },
         Halt::NotEnoughGasProvided { 
         }
          => { format!("[anvil-halt-14] Bootloader did not have enough gas to start the transaction") },
         Halt::MissingInvocationLimitReached { 
         }
          => { format!("[anvil-halt-15] Transaction produced too much storage accesses.") },
         Halt::FailedToSetL2Block { 
            msg,
         }
          => { format!("[anvil-halt-16] Failed to set information about the L2 block: {msg}") },
         Halt::FailedToAppendTransactionToL2Block { 
            msg,
         }
          => { format!("[anvil-halt-17] Failed to append the transaction to the current L2 block: {msg}") },
         Halt::VMPanic { 
         }
          => { format!("[anvil-halt-18] VM panicked") },
         Halt::TracerCustom { 
            msg,
         }
          => { format!("[anvil-halt-19] Tracer aborted execution: {msg}") },
         Halt::FailedToPublishCompressedBytecodes { 
         }
          => { format!("[anvil-halt-20] Failed to publish compressed bytecodes") },
         Halt::FailedBlockTimestampAssertion { 
         }
          => { format!("[anvil-halt-21] Transaction failed `block.timestamp` assertion") },
         Halt::GenericError { 
            message,
         }
          => { format!("[anvil-halt-0] Generic error: {message}") },
      }
   }
}

impl From<Halt> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Halt) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Halt> for crate::serialized::SerializedError {
    fn from(value: Halt) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(RevertCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Revert {
   /// # Short description
   /// Execution reverted due to a failure.
   ///
   /// # Description
   /// This error indicates that the transaction execution was reverted.
   General {
      msg : String,
      data : Vec<u8>,
   } = 1, 
   /// # Short description
   /// An inner transaction error occurred.
   ///
   /// # Description
   /// This error is emitted when an inner transaction within the VM fails, typically related to bootloader execution.
   InnerTxError  = 2, 
   /// # Short description
   /// A generic VM error.
   ///
   /// # Description
   /// This error indicates a generic failure within the VM, without specific details.
   VmError  = 3, 
   /// # Short description
   /// An unknown VM revert reason was encountered.
   ///
   /// # Description
   /// This error is emitted when the VM encounters a revert reason that is not recognized, including the function selector and raw data for debugging.
   Unknown {
      function_selector : String,
      data : String,
   } = 4, 
   GenericError {
      message : String,
   } = 0, 
   
} // end of Revert


impl std::error::Error for Revert {}

impl NamedError for Revert {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for RevertCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Revert> for crate::ZksyncError {
    fn from(val: Revert) -> Self {
        val.to_unified()
    }
}


impl Documented for Revert {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Revert {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Revert {
    fn get_message(&self) -> String {
        match self {
         Revert::General { 
            msg,
            data,
         }
          => { format!("[anvil-revert-1] General revert error: {msg}") },
         Revert::InnerTxError { 
         }
          => { format!("[anvil-revert-2] Bootloader-based transaction failed.") },
         Revert::VmError { 
         }
          => { format!("[anvil-revert-3] VM Error") },
         Revert::Unknown { 
            function_selector,
            data,
         }
          => { format!("[anvil-revert-4] Unknown VM revert reason: function_selector={function_selector}, data={data}") },
         Revert::GenericError { 
            message,
         }
          => { format!("[anvil-revert-0] Generic error: {message}") },
      }
   }
}

impl From<Revert> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Revert) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Revert> for crate::serialized::SerializedError {
    fn from(value: Revert) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the compiler backend for Ethereum VM (EVM).

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(LLVM_EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_EVM {
   GenericError {
      message : String,
   } = 0, 
   
} // end of LLVM_EVM


impl std::error::Error for LLVM_EVM {}

impl NamedError for LLVM_EVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<LLVM_EVM> for crate::ZksyncError {
    fn from(val: LLVM_EVM) -> Self {
        val.to_unified()
    }
}


impl Documented for LLVM_EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for LLVM_EVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for LLVM_EVM {
    fn get_message(&self) -> String {
        match self {
         LLVM_EVM::GenericError { 
            message,
         }
          => { format!("[compiler-llvm+evm-0] Generic error: {message}") },
      }
   }
}

impl From<LLVM_EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_EVM) -> Self {
        crate::packed::pack(value)
    }
}

impl From<LLVM_EVM> for crate::serialized::SerializedError {
    fn from(value: LLVM_EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the compiler backend for EraVM.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(LLVM_EraCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_Era {
   GenericError {
      message : String,
   } = 0, 
   
} // end of LLVM_Era


impl std::error::Error for LLVM_Era {}

impl NamedError for LLVM_Era {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EraCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<LLVM_Era> for crate::ZksyncError {
    fn from(val: LLVM_Era) -> Self {
        val.to_unified()
    }
}


impl Documented for LLVM_Era {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for LLVM_Era {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for LLVM_Era {
    fn get_message(&self) -> String {
        match self {
         LLVM_Era::GenericError { 
            message,
         }
          => { format!("[compiler-llvm+era-0] Generic error: {message}") },
      }
   }
}

impl From<LLVM_Era> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_Era) -> Self {
        crate::packed::pack(value)
    }
}

impl From<LLVM_Era> for crate::serialized::SerializedError {
    fn from(value: LLVM_Era) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the official Solidity compiler.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(SolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Solc {
   GenericError {
      message : String,
   } = 0, 
   
} // end of Solc


impl std::error::Error for Solc {}

impl NamedError for Solc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Solc> for crate::ZksyncError {
    fn from(val: Solc) -> Self {
        val.to_unified()
    }
}


impl Documented for Solc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Solc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Solc {
    fn get_message(&self) -> String {
        match self {
         Solc::GenericError { 
            message,
         }
          => { format!("[compiler-solc-0] Generic error: {message}") },
      }
   }
}

impl From<Solc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Solc) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Solc> for crate::serialized::SerializedError {
    fn from(value: Solc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync fork of Solidity compiler.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(SolcForkCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum SolcFork {
   GenericError {
      message : String,
   } = 0, 
   
} // end of SolcFork


impl std::error::Error for SolcFork {}

impl NamedError for SolcFork {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcForkCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<SolcFork> for crate::ZksyncError {
    fn from(val: SolcFork) -> Self {
        val.to_unified()
    }
}


impl Documented for SolcFork {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for SolcFork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for SolcFork {
    fn get_message(&self) -> String {
        match self {
         SolcFork::GenericError { 
            message,
         }
          => { format!("[compiler-solc+fork-0] Generic error: {message}") },
      }
   }
}

impl From<SolcFork> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SolcFork) -> Self {
        crate::packed::pack(value)
    }
}

impl From<SolcFork> for crate::serialized::SerializedError {
    fn from(value: SolcFork) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync Solidity compiler for EraVM and EVM.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(ZksolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zksolc {
   GenericError {
      message : String,
   } = 0, 
   
} // end of Zksolc


impl std::error::Error for Zksolc {}

impl NamedError for Zksolc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZksolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Zksolc> for crate::ZksyncError {
    fn from(val: Zksolc) -> Self {
        val.to_unified()
    }
}


impl Documented for Zksolc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Zksolc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Zksolc {
    fn get_message(&self) -> String {
        match self {
         Zksolc::GenericError { 
            message,
         }
          => { format!("[compiler-zksolc-0] Generic error: {message}") },
      }
   }
}

impl From<Zksolc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zksolc) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Zksolc> for crate::serialized::SerializedError {
    fn from(value: Zksolc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync Vyper compiler for EraVM.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(ZkvyperCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zkvyper {
   GenericError {
      message : String,
   } = 0, 
   
} // end of Zkvyper


impl std::error::Error for Zkvyper {}

impl NamedError for Zkvyper {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZkvyperCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Zkvyper> for crate::ZksyncError {
    fn from(val: Zkvyper) -> Self {
        val.to_unified()
    }
}


impl Documented for Zkvyper {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Zkvyper {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Zkvyper {
    fn get_message(&self) -> String {
        match self {
         Zkvyper::GenericError { 
            message,
         }
          => { format!("[compiler-zkvyper-0] Generic error: {message}") },
      }
   }
}

impl From<Zkvyper> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zkvyper) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Zkvyper> for crate::serialized::SerializedError {
    fn from(value: Zkvyper) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the web3 API.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(APICode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum API {
   GenericError {
      message : String,
   } = 0, 
   
} // end of API


impl std::error::Error for API {}

impl NamedError for API {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for APICode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<API> for crate::ZksyncError {
    fn from(val: API) -> Self {
        val.to_unified()
    }
}


impl Documented for API {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for API {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for API {
    fn get_message(&self) -> String {
        match self {
         API::GenericError { 
            message,
         }
          => { format!("[core-api-0] Generic error: {message}") },
      }
   }
}

impl From<API> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: API) -> Self {
        crate::packed::pack(value)
    }
}

impl From<API> for crate::serialized::SerializedError {
    fn from(value: API) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors in EraVM virtual machine executing contracts.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(EraVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum EraVM {
   GenericError {
      message : String,
   } = 0, 
   
} // end of EraVM


impl std::error::Error for EraVM {}

impl NamedError for EraVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for EraVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<EraVM> for crate::ZksyncError {
    fn from(val: EraVM) -> Self {
        val.to_unified()
    }
}


impl Documented for EraVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for EraVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for EraVM {
    fn get_message(&self) -> String {
        match self {
         EraVM::GenericError { 
            message,
         }
          => { format!("[core-eravm-0] Generic error: {message}") },
      }
   }
}

impl From<EraVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EraVM) -> Self {
        crate::packed::pack(value)
    }
}

impl From<EraVM> for crate::serialized::SerializedError {
    fn from(value: EraVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors in the contract execution environment, bootloader, etc.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(ExecutionPlatformCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum ExecutionPlatform {
   GenericError {
      message : String,
   } = 0, 
   
} // end of ExecutionPlatform


impl std::error::Error for ExecutionPlatform {}

impl NamedError for ExecutionPlatform {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ExecutionPlatformCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<ExecutionPlatform> for crate::ZksyncError {
    fn from(val: ExecutionPlatform) -> Self {
        val.to_unified()
    }
}


impl Documented for ExecutionPlatform {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for ExecutionPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for ExecutionPlatform {
    fn get_message(&self) -> String {
        match self {
         ExecutionPlatform::GenericError { 
            message,
         }
          => { format!("[core-exec-0] Generic error: {message}") },
      }
   }
}

impl From<ExecutionPlatform> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: ExecutionPlatform) -> Self {
        crate::packed::pack(value)
    }
}

impl From<ExecutionPlatform> for crate::serialized::SerializedError {
    fn from(value: ExecutionPlatform) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors in the sequencer node

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(SequencerCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Sequencer {
   GenericSequencerError {
      message : String,
   } = 1, 
   GenericError {
      message : String,
   } = 0, 
   
} // end of Sequencer


impl std::error::Error for Sequencer {}

impl NamedError for Sequencer {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SequencerCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<Sequencer> for crate::ZksyncError {
    fn from(val: Sequencer) -> Self {
        val.to_unified()
    }
}


impl Documented for Sequencer {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for Sequencer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for Sequencer {
    fn get_message(&self) -> String {
        match self {
         Sequencer::GenericSequencerError { 
            message,
         }
          => { format!("[core-seq-1] Generic error: {message}") },
         Sequencer::GenericError { 
            message,
         }
          => { format!("[core-seq-0] Generic error: {message}") },
      }
   }
}

impl From<Sequencer> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Sequencer) -> Self {
        crate::packed::pack(value)
    }
}

impl From<Sequencer> for crate::serialized::SerializedError {
    fn from(value: Sequencer) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the upstream Foundry implementation.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(FoundryUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryUpstream {
   GenericError {
      message : String,
   } = 0, 
   
} // end of FoundryUpstream


impl std::error::Error for FoundryUpstream {}

impl NamedError for FoundryUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<FoundryUpstream> for crate::ZksyncError {
    fn from(val: FoundryUpstream) -> Self {
        val.to_unified()
    }
}


impl Documented for FoundryUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for FoundryUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for FoundryUpstream {
    fn get_message(&self) -> String {
        match self {
         FoundryUpstream::GenericError { 
            message,
         }
          => { format!("[foundry-upstream-0] Generic error: {message}") },
      }
   }
}

impl From<FoundryUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryUpstream) -> Self {
        crate::packed::pack(value)
    }
}

impl From<FoundryUpstream> for crate::serialized::SerializedError {
    fn from(value: FoundryUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync codebase for Foundry.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(FoundryZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryZksync {
   GenericError {
      message : String,
   } = 0, 
   
} // end of FoundryZksync


impl std::error::Error for FoundryZksync {}

impl NamedError for FoundryZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<FoundryZksync> for crate::ZksyncError {
    fn from(val: FoundryZksync) -> Self {
        val.to_unified()
    }
}


impl Documented for FoundryZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for FoundryZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for FoundryZksync {
    fn get_message(&self) -> String {
        match self {
         FoundryZksync::GenericError { 
            message,
         }
          => { format!("[foundry-zksync-0] Generic error: {message}") },
      }
   }
}

impl From<FoundryZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryZksync) -> Self {
        crate::packed::pack(value)
    }
}

impl From<FoundryZksync> for crate::serialized::SerializedError {
    fn from(value: FoundryZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the upstream Hardhat implementation.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(HardhatUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatUpstream {
   GenericError {
      message : String,
   } = 0, 
   
} // end of HardhatUpstream


impl std::error::Error for HardhatUpstream {}

impl NamedError for HardhatUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<HardhatUpstream> for crate::ZksyncError {
    fn from(val: HardhatUpstream) -> Self {
        val.to_unified()
    }
}


impl Documented for HardhatUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for HardhatUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for HardhatUpstream {
    fn get_message(&self) -> String {
        match self {
         HardhatUpstream::GenericError { 
            message,
         }
          => { format!("[hardhat-upstream-0] Generic error: {message}") },
      }
   }
}

impl From<HardhatUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatUpstream) -> Self {
        crate::packed::pack(value)
    }
}

impl From<HardhatUpstream> for crate::serialized::SerializedError {
    fn from(value: HardhatUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
/// Errors originating in the ZKsync codebase for HardHat.

#[repr(u32)]
#[derive(AsRefStr, Clone, Debug, Eq, EnumDiscriminants, PartialEq, serde::Serialize, serde::Deserialize)]
#[strum_discriminants(name(HardhatZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatZksync {
   GenericError {
      message : String,
   } = 0, 
   
} // end of HardhatZksync


impl std::error::Error for HardhatZksync {}

impl NamedError for HardhatZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}

impl From<HardhatZksync> for crate::ZksyncError {
    fn from(val: HardhatZksync) -> Self {
        val.to_unified()
    }
}


impl Documented for HardhatZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;

    fn get_documentation(&self) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}


impl std::fmt::Display for HardhatZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
       f.write_fmt(format_args!("{self:?}"))
    }
}


impl CustomErrorMessage for HardhatZksync {
    fn get_message(&self) -> String {
        match self {
         HardhatZksync::GenericError { 
            message,
         }
          => { format!("[hardhat-zksync-0] Generic error: {message}") },
      }
   }
}

impl From<HardhatZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatZksync) -> Self {
        crate::packed::pack(value)
    }
}

impl From<HardhatZksync> for crate::serialized::SerializedError {
    fn from(value: HardhatZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
