//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(unused)]
#![allow(clippy::useless_format)]
#![allow(non_camel_case_types)]
use crate::documentation::Documented;
use crate::error::CustomErrorMessage;
use crate::error::ICustomError as _;
use crate::error::IError as _;
use crate::error::NamedError;
use strum_macros::AsRefStr;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(AnvilEnvironmentCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilEnvironment {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for AnvilEnvironment {}
impl NamedError for AnvilEnvironment {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilEnvironmentCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilEnvironment> for crate::ZksyncError {
    fn from(val: AnvilEnvironment) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for AnvilEnvironment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for AnvilEnvironment {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for AnvilEnvironment {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilEnvironment::GenericError { message }
    }
}
impl From<AnvilEnvironment> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilEnvironment) -> Self {
        crate::packed::pack(value)
    }
}
impl From<AnvilEnvironment> for crate::serialized::SerializedError {
    fn from(value: AnvilEnvironment) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilEnvironment {
    fn get_message(&self) -> String {
        match self {
            AnvilEnvironment::GenericError { message } => {
                format!("[anvil_zksync-env-0] Generic error: {message}")
            }
        }
    }
}
#[doc = ""]
#[doc = ""]
#[doc = "Domain: AnvilZKsync"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(AnvilGenericCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum AnvilGeneric {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for AnvilGeneric {}
impl NamedError for AnvilGeneric {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for AnvilGenericCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<AnvilGeneric> for crate::ZksyncError {
    fn from(val: AnvilGeneric) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for AnvilGeneric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for AnvilGeneric {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for AnvilGeneric {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        AnvilGeneric::GenericError { message }
    }
}
impl From<AnvilGeneric> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: AnvilGeneric) -> Self {
        crate::packed::pack(value)
    }
}
impl From<AnvilGeneric> for crate::serialized::SerializedError {
    fn from(value: AnvilGeneric) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for AnvilGeneric {
    fn get_message(&self) -> String {
        match self {
            AnvilGeneric::GenericError { message } => {
                format!("[anvil_zksync-gen-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for Ethereum VM (EVM)."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(LLVM_EVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_EVM {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for LLVM_EVM {}
impl NamedError for LLVM_EVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<LLVM_EVM> for crate::ZksyncError {
    fn from(val: LLVM_EVM) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for LLVM_EVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for LLVM_EVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for LLVM_EVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_EVM::GenericError { message }
    }
}
impl From<LLVM_EVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_EVM) -> Self {
        crate::packed::pack(value)
    }
}
impl From<LLVM_EVM> for crate::serialized::SerializedError {
    fn from(value: LLVM_EVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for LLVM_EVM {
    fn get_message(&self) -> String {
        match self {
            LLVM_EVM::GenericError { message } => {
                format!("[compiler-llvm+evm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the compiler backend for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(LLVM_EraCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum LLVM_Era {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for LLVM_Era {}
impl NamedError for LLVM_Era {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for LLVM_EraCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<LLVM_Era> for crate::ZksyncError {
    fn from(val: LLVM_Era) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for LLVM_Era {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for LLVM_Era {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for LLVM_Era {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        LLVM_Era::GenericError { message }
    }
}
impl From<LLVM_Era> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: LLVM_Era) -> Self {
        crate::packed::pack(value)
    }
}
impl From<LLVM_Era> for crate::serialized::SerializedError {
    fn from(value: LLVM_Era) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for LLVM_Era {
    fn get_message(&self) -> String {
        match self {
            LLVM_Era::GenericError { message } => {
                format!("[compiler-llvm+era-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the official Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Solc {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Solc {}
impl NamedError for Solc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Solc> for crate::ZksyncError {
    fn from(val: Solc) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Solc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Solc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Solc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Solc::GenericError { message }
    }
}
impl From<Solc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Solc) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Solc> for crate::serialized::SerializedError {
    fn from(value: Solc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Solc {
    fn get_message(&self) -> String {
        match self {
            Solc::GenericError { message } => {
                format!("[compiler-solc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync fork of Solidity compiler."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SolcForkCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum SolcFork {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for SolcFork {}
impl NamedError for SolcFork {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SolcForkCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<SolcFork> for crate::ZksyncError {
    fn from(val: SolcFork) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for SolcFork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for SolcFork {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for SolcFork {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        SolcFork::GenericError { message }
    }
}
impl From<SolcFork> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: SolcFork) -> Self {
        crate::packed::pack(value)
    }
}
impl From<SolcFork> for crate::serialized::SerializedError {
    fn from(value: SolcFork) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for SolcFork {
    fn get_message(&self) -> String {
        match self {
            SolcFork::GenericError { message } => {
                format!("[compiler-solc+fork-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Solidity compiler for EraVM and EVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ZksolcCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zksolc {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Zksolc {}
impl NamedError for Zksolc {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZksolcCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Zksolc> for crate::ZksyncError {
    fn from(val: Zksolc) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Zksolc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Zksolc {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Zksolc {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zksolc::GenericError { message }
    }
}
impl From<Zksolc> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zksolc) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Zksolc> for crate::serialized::SerializedError {
    fn from(value: Zksolc) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Zksolc {
    fn get_message(&self) -> String {
        match self {
            Zksolc::GenericError { message } => {
                format!("[compiler-zksolc-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync Vyper compiler for EraVM."]
#[doc = ""]
#[doc = "Domain: Compiler"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ZkvyperCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Zkvyper {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Zkvyper {}
impl NamedError for Zkvyper {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ZkvyperCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Zkvyper> for crate::ZksyncError {
    fn from(val: Zkvyper) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Zkvyper {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Zkvyper {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Zkvyper {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Zkvyper::GenericError { message }
    }
}
impl From<Zkvyper> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Zkvyper) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Zkvyper> for crate::serialized::SerializedError {
    fn from(value: Zkvyper) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Zkvyper {
    fn get_message(&self) -> String {
        match self {
            Zkvyper::GenericError { message } => {
                format!("[compiler-zkvyper-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the web3 API."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(APICode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum API {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for API {}
impl NamedError for API {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for APICode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<API> for crate::ZksyncError {
    fn from(val: API) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for API {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for API {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for API {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        API::GenericError { message }
    }
}
impl From<API> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: API) -> Self {
        crate::packed::pack(value)
    }
}
impl From<API> for crate::serialized::SerializedError {
    fn from(value: API) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for API {
    fn get_message(&self) -> String {
        match self {
            API::GenericError { message } => {
                format!("[core-api-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in EraVM virtual machine executing contracts."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(EraVMCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum EraVM {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for EraVM {}
impl NamedError for EraVM {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for EraVMCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<EraVM> for crate::ZksyncError {
    fn from(val: EraVM) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for EraVM {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for EraVM {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for EraVM {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        EraVM::GenericError { message }
    }
}
impl From<EraVM> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: EraVM) -> Self {
        crate::packed::pack(value)
    }
}
impl From<EraVM> for crate::serialized::SerializedError {
    fn from(value: EraVM) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for EraVM {
    fn get_message(&self) -> String {
        match self {
            EraVM::GenericError { message } => {
                format!("[core-eravm-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the contract execution environment, bootloader, etc."]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(ExecutionPlatformCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum ExecutionPlatform {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for ExecutionPlatform {}
impl NamedError for ExecutionPlatform {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for ExecutionPlatformCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<ExecutionPlatform> for crate::ZksyncError {
    fn from(val: ExecutionPlatform) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for ExecutionPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for ExecutionPlatform {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for ExecutionPlatform {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        ExecutionPlatform::GenericError { message }
    }
}
impl From<ExecutionPlatform> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: ExecutionPlatform) -> Self {
        crate::packed::pack(value)
    }
}
impl From<ExecutionPlatform> for crate::serialized::SerializedError {
    fn from(value: ExecutionPlatform) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for ExecutionPlatform {
    fn get_message(&self) -> String {
        match self {
            ExecutionPlatform::GenericError { message } => {
                format!("[core-exec-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors in the sequencer node"]
#[doc = ""]
#[doc = "Domain: Core"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(SequencerCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum Sequencer {
    GenericSequencerError { message: String } = 1u32,
    GenericError { message: String } = 0u32,
}
impl std::error::Error for Sequencer {}
impl NamedError for Sequencer {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for SequencerCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<Sequencer> for crate::ZksyncError {
    fn from(val: Sequencer) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for Sequencer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for Sequencer {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for Sequencer {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        Sequencer::GenericError { message }
    }
}
impl From<Sequencer> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: Sequencer) -> Self {
        crate::packed::pack(value)
    }
}
impl From<Sequencer> for crate::serialized::SerializedError {
    fn from(value: Sequencer) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for Sequencer {
    fn get_message(&self) -> String {
        match self {
            Sequencer::GenericSequencerError { message } => {
                format!("[core-seq-1] Generic error: {message}")
            }
            Sequencer::GenericError { message } => {
                format!("[core-seq-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Foundry implementation."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(FoundryUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryUpstream {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for FoundryUpstream {}
impl NamedError for FoundryUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<FoundryUpstream> for crate::ZksyncError {
    fn from(val: FoundryUpstream) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for FoundryUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for FoundryUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for FoundryUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryUpstream::GenericError { message }
    }
}
impl From<FoundryUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryUpstream) -> Self {
        crate::packed::pack(value)
    }
}
impl From<FoundryUpstream> for crate::serialized::SerializedError {
    fn from(value: FoundryUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for FoundryUpstream {
    fn get_message(&self) -> String {
        match self {
            FoundryUpstream::GenericError { message } => {
                format!("[foundry-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for Foundry."]
#[doc = ""]
#[doc = "Domain: Foundry"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(FoundryZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum FoundryZksync {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for FoundryZksync {}
impl NamedError for FoundryZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for FoundryZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<FoundryZksync> for crate::ZksyncError {
    fn from(val: FoundryZksync) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for FoundryZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for FoundryZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for FoundryZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        FoundryZksync::GenericError { message }
    }
}
impl From<FoundryZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: FoundryZksync) -> Self {
        crate::packed::pack(value)
    }
}
impl From<FoundryZksync> for crate::serialized::SerializedError {
    fn from(value: FoundryZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for FoundryZksync {
    fn get_message(&self) -> String {
        match self {
            FoundryZksync::GenericError { message } => {
                format!("[foundry-zksync-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the upstream Hardhat implementation."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HardhatUpstreamCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatUpstream {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for HardhatUpstream {}
impl NamedError for HardhatUpstream {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatUpstreamCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<HardhatUpstream> for crate::ZksyncError {
    fn from(val: HardhatUpstream) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for HardhatUpstream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for HardhatUpstream {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for HardhatUpstream {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatUpstream::GenericError { message }
    }
}
impl From<HardhatUpstream> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatUpstream) -> Self {
        crate::packed::pack(value)
    }
}
impl From<HardhatUpstream> for crate::serialized::SerializedError {
    fn from(value: HardhatUpstream) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for HardhatUpstream {
    fn get_message(&self) -> String {
        match self {
            HardhatUpstream::GenericError { message } => {
                format!("[hardhat-upstream-0] Generic error: {message}")
            }
        }
    }
}
#[doc = "Errors originating in the ZKsync codebase for HardHat."]
#[doc = ""]
#[doc = "Domain: Hardhat"]
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    Eq,
    EnumDiscriminants,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HardhatZksyncCode))]
#[strum_discriminants(vis(pub))]
#[strum_discriminants(derive(AsRefStr, FromRepr))]
#[non_exhaustive]
pub enum HardhatZksync {
    GenericError { message: String } = 0u32,
}
impl std::error::Error for HardhatZksync {}
impl NamedError for HardhatZksync {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl NamedError for HardhatZksyncCode {
    fn get_error_name(&self) -> String {
        self.as_ref().to_owned()
    }
}
impl From<HardhatZksync> for crate::ZksyncError {
    fn from(val: HardhatZksync) -> Self {
        val.to_unified()
    }
}
impl std::fmt::Display for HardhatZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{self:?}"))
    }
}
impl Documented for HardhatZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        self.to_unified().get_identifier().get_documentation()
    }
}
impl From<anyhow::Error> for HardhatZksync {
    fn from(value: anyhow::Error) -> Self {
        let message = format!("{value:#?}");
        HardhatZksync::GenericError { message }
    }
}
impl From<HardhatZksync> for crate::packed::PackedError<crate::error::domains::ZksyncError> {
    fn from(value: HardhatZksync) -> Self {
        crate::packed::pack(value)
    }
}
impl From<HardhatZksync> for crate::serialized::SerializedError {
    fn from(value: HardhatZksync) -> Self {
        let packed = crate::packed::pack(value);
        crate::serialized::serialize(packed).expect("Internal serialization error.")
    }
}
impl CustomErrorMessage for HardhatZksync {
    fn get_message(&self) -> String {
        match self {
            HardhatZksync::GenericError { message } => {
                format!("[hardhat-zksync-0] Generic error: {message}")
            }
        }
    }
}
