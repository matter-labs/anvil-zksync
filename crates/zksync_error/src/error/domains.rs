//
// AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//
#![allow(non_camel_case_types)]
use crate::error::definitions::APICode;
use crate::error::definitions::AnvilEnvironment;
use crate::error::definitions::AnvilEnvironmentCode;
use crate::error::definitions::AnvilGeneric;
use crate::error::definitions::AnvilGenericCode;
use crate::error::definitions::AnvilNode;
use crate::error::definitions::AnvilNodeCode;
use crate::error::definitions::EraVM;
use crate::error::definitions::EraVMCode;
use crate::error::definitions::ExecutionPlatform;
use crate::error::definitions::ExecutionPlatformCode;
use crate::error::definitions::FoundryUpstream;
use crate::error::definitions::FoundryUpstreamCode;
use crate::error::definitions::FoundryZksync;
use crate::error::definitions::FoundryZksyncCode;
use crate::error::definitions::Halt;
use crate::error::definitions::HaltCode;
use crate::error::definitions::HardhatUpstream;
use crate::error::definitions::HardhatUpstreamCode;
use crate::error::definitions::HardhatZksync;
use crate::error::definitions::HardhatZksyncCode;
use crate::error::definitions::LLVM_EVMCode;
use crate::error::definitions::LLVM_Era;
use crate::error::definitions::LLVM_EraCode;
use crate::error::definitions::Revert;
use crate::error::definitions::RevertCode;
use crate::error::definitions::Sequencer;
use crate::error::definitions::SequencerCode;
use crate::error::definitions::Solc;
use crate::error::definitions::SolcCode;
use crate::error::definitions::SolcFork;
use crate::error::definitions::SolcForkCode;
use crate::error::definitions::StateLoader;
use crate::error::definitions::StateLoaderCode;
use crate::error::definitions::TransactionValidation;
use crate::error::definitions::TransactionValidationCode;
use crate::error::definitions::Zksolc;
use crate::error::definitions::ZksolcCode;
use crate::error::definitions::Zkvyper;
use crate::error::definitions::ZkvyperCode;
use crate::error::definitions::API;
use crate::error::definitions::LLVM_EVM;
use crate::error::ICustomError;
use crate::error::IUnifiedError;
use crate::kind::Kind;
use strum_macros::AsRefStr;
use strum_macros::EnumDiscriminants;
use strum_macros::FromRepr;
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    EnumDiscriminants,
    Eq,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
pub enum ZksyncError {
    AnvilZksync(AnvilZksync),
    Compiler(Compiler),
    Core(Core),
    Foundry(Foundry),
    Hardhat(Hardhat),
}
impl crate::documentation::Documented for ZksyncError {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            ZksyncError::AnvilZksync(error) => error.get_documentation(),
            ZksyncError::Compiler(error) => error.get_documentation(),
            ZksyncError::Core(error) => error.get_documentation(),
            ZksyncError::Foundry(error) => error.get_documentation(),
            ZksyncError::Hardhat(error) => error.get_documentation(),
        }
    }
}
impl std::fmt::Display for ZksyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ZksyncError::AnvilZksync(domain_error) => domain_error.fmt(f),
            ZksyncError::Compiler(domain_error) => domain_error.fmt(f),
            ZksyncError::Core(domain_error) => domain_error.fmt(f),
            ZksyncError::Foundry(domain_error) => domain_error.fmt(f),
            ZksyncError::Hardhat(domain_error) => domain_error.fmt(f),
        }
    }
}
impl ZksyncError {
    pub fn get_kind(&self) -> crate::kind::Kind {
        match self {
            ZksyncError::AnvilZksync(AnvilZksync::AnvilEnvironment(_)) => {
                Kind::AnvilZksync(AnvilZksyncCode::AnvilEnvironment)
            }
            ZksyncError::AnvilZksync(AnvilZksync::AnvilGeneric(_)) => {
                Kind::AnvilZksync(AnvilZksyncCode::AnvilGeneric)
            }
            ZksyncError::AnvilZksync(AnvilZksync::AnvilNode(_)) => {
                Kind::AnvilZksync(AnvilZksyncCode::AnvilNode)
            }
            ZksyncError::AnvilZksync(AnvilZksync::Halt(_)) => {
                Kind::AnvilZksync(AnvilZksyncCode::Halt)
            }
            ZksyncError::AnvilZksync(AnvilZksync::Revert(_)) => {
                Kind::AnvilZksync(AnvilZksyncCode::Revert)
            }
            ZksyncError::AnvilZksync(AnvilZksync::StateLoader(_)) => {
                Kind::AnvilZksync(AnvilZksyncCode::StateLoader)
            }
            ZksyncError::AnvilZksync(AnvilZksync::TransactionValidation(_)) => {
                Kind::AnvilZksync(AnvilZksyncCode::TransactionValidation)
            }
            ZksyncError::Compiler(Compiler::LLVM_EVM(_)) => Kind::Compiler(CompilerCode::LLVM_EVM),
            ZksyncError::Compiler(Compiler::LLVM_Era(_)) => Kind::Compiler(CompilerCode::LLVM_Era),
            ZksyncError::Compiler(Compiler::Solc(_)) => Kind::Compiler(CompilerCode::Solc),
            ZksyncError::Compiler(Compiler::SolcFork(_)) => Kind::Compiler(CompilerCode::SolcFork),
            ZksyncError::Compiler(Compiler::Zksolc(_)) => Kind::Compiler(CompilerCode::Zksolc),
            ZksyncError::Compiler(Compiler::Zkvyper(_)) => Kind::Compiler(CompilerCode::Zkvyper),
            ZksyncError::Core(Core::API(_)) => Kind::Core(CoreCode::API),
            ZksyncError::Core(Core::EraVM(_)) => Kind::Core(CoreCode::EraVM),
            ZksyncError::Core(Core::ExecutionPlatform(_)) => {
                Kind::Core(CoreCode::ExecutionPlatform)
            }
            ZksyncError::Core(Core::Sequencer(_)) => Kind::Core(CoreCode::Sequencer),
            ZksyncError::Foundry(Foundry::FoundryUpstream(_)) => {
                Kind::Foundry(FoundryCode::FoundryUpstream)
            }
            ZksyncError::Foundry(Foundry::FoundryZksync(_)) => {
                Kind::Foundry(FoundryCode::FoundryZksync)
            }
            ZksyncError::Hardhat(Hardhat::HardhatUpstream(_)) => {
                Kind::Hardhat(HardhatCode::HardhatUpstream)
            }
            ZksyncError::Hardhat(Hardhat::HardhatZksync(_)) => {
                Kind::Hardhat(HardhatCode::HardhatZksync)
            }
        }
    }
    pub fn get_code(&self) -> u32 {
        match self {
            ZksyncError::AnvilZksync(AnvilZksync::AnvilEnvironment(error)) => {
                Into::<AnvilEnvironmentCode>::into(error) as u32
            }
            ZksyncError::AnvilZksync(AnvilZksync::AnvilGeneric(error)) => {
                Into::<AnvilGenericCode>::into(error) as u32
            }
            ZksyncError::AnvilZksync(AnvilZksync::AnvilNode(error)) => {
                Into::<AnvilNodeCode>::into(error) as u32
            }
            ZksyncError::AnvilZksync(AnvilZksync::Halt(error)) => {
                Into::<HaltCode>::into(error) as u32
            }
            ZksyncError::AnvilZksync(AnvilZksync::Revert(error)) => {
                Into::<RevertCode>::into(error) as u32
            }
            ZksyncError::AnvilZksync(AnvilZksync::StateLoader(error)) => {
                Into::<StateLoaderCode>::into(error) as u32
            }
            ZksyncError::AnvilZksync(AnvilZksync::TransactionValidation(error)) => {
                Into::<TransactionValidationCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::LLVM_EVM(error)) => {
                Into::<LLVM_EVMCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::LLVM_Era(error)) => {
                Into::<LLVM_EraCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::Solc(error)) => Into::<SolcCode>::into(error) as u32,
            ZksyncError::Compiler(Compiler::SolcFork(error)) => {
                Into::<SolcForkCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::Zksolc(error)) => {
                Into::<ZksolcCode>::into(error) as u32
            }
            ZksyncError::Compiler(Compiler::Zkvyper(error)) => {
                Into::<ZkvyperCode>::into(error) as u32
            }
            ZksyncError::Core(Core::API(error)) => Into::<APICode>::into(error) as u32,
            ZksyncError::Core(Core::EraVM(error)) => Into::<EraVMCode>::into(error) as u32,
            ZksyncError::Core(Core::ExecutionPlatform(error)) => {
                Into::<ExecutionPlatformCode>::into(error) as u32
            }
            ZksyncError::Core(Core::Sequencer(error)) => Into::<SequencerCode>::into(error) as u32,
            ZksyncError::Foundry(Foundry::FoundryUpstream(error)) => {
                Into::<FoundryUpstreamCode>::into(error) as u32
            }
            ZksyncError::Foundry(Foundry::FoundryZksync(error)) => {
                Into::<FoundryZksyncCode>::into(error) as u32
            }
            ZksyncError::Hardhat(Hardhat::HardhatUpstream(error)) => {
                Into::<HardhatUpstreamCode>::into(error) as u32
            }
            ZksyncError::Hardhat(Hardhat::HardhatZksync(error)) => {
                Into::<HardhatZksyncCode>::into(error) as u32
            }
        }
    }
}
impl IUnifiedError<ZksyncError> for ZksyncError {}
impl std::error::Error for ZksyncError {}
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    EnumDiscriminants,
    Eq,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(AnvilZksyncCode))]
#[strum_discriminants(derive(serde::Serialize, serde::Deserialize, FromRepr))]
#[strum_discriminants(vis(pub))]
pub enum AnvilZksync {
    AnvilEnvironment(AnvilEnvironment),
    AnvilGeneric(AnvilGeneric),
    AnvilNode(AnvilNode),
    Halt(Halt),
    Revert(Revert),
    StateLoader(StateLoader),
    TransactionValidation(TransactionValidation),
}
impl AnvilZksync {
    pub fn get_name(&self) -> &str {
        self.as_ref()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for AnvilEnvironment {
    fn to_unified(&self) -> ZksyncError {
        AnvilZksync::AnvilEnvironment(self.clone()).to_unified()
    }
}
impl From<AnvilEnvironment> for AnvilZksync {
    fn from(val: AnvilEnvironment) -> Self {
        AnvilZksync::AnvilEnvironment(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for AnvilGeneric {
    fn to_unified(&self) -> ZksyncError {
        AnvilZksync::AnvilGeneric(self.clone()).to_unified()
    }
}
impl From<AnvilGeneric> for AnvilZksync {
    fn from(val: AnvilGeneric) -> Self {
        AnvilZksync::AnvilGeneric(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for AnvilNode {
    fn to_unified(&self) -> ZksyncError {
        AnvilZksync::AnvilNode(self.clone()).to_unified()
    }
}
impl From<AnvilNode> for AnvilZksync {
    fn from(val: AnvilNode) -> Self {
        AnvilZksync::AnvilNode(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Halt {
    fn to_unified(&self) -> ZksyncError {
        AnvilZksync::Halt(self.clone()).to_unified()
    }
}
impl From<Halt> for AnvilZksync {
    fn from(val: Halt) -> Self {
        AnvilZksync::Halt(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Revert {
    fn to_unified(&self) -> ZksyncError {
        AnvilZksync::Revert(self.clone()).to_unified()
    }
}
impl From<Revert> for AnvilZksync {
    fn from(val: Revert) -> Self {
        AnvilZksync::Revert(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for StateLoader {
    fn to_unified(&self) -> ZksyncError {
        AnvilZksync::StateLoader(self.clone()).to_unified()
    }
}
impl From<StateLoader> for AnvilZksync {
    fn from(val: StateLoader) -> Self {
        AnvilZksync::StateLoader(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for TransactionValidation {
    fn to_unified(&self) -> ZksyncError {
        AnvilZksync::TransactionValidation(self.clone()).to_unified()
    }
}
impl From<TransactionValidation> for AnvilZksync {
    fn from(val: TransactionValidation) -> Self {
        AnvilZksync::TransactionValidation(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for AnvilZksync {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::AnvilZksync(self.clone())
    }
}
impl From<AnvilZksync> for ZksyncError {
    fn from(value: AnvilZksync) -> Self {
        value.to_unified()
    }
}
impl crate::documentation::Documented for AnvilZksync {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            AnvilZksync::AnvilEnvironment(error) => error.get_documentation(),
            AnvilZksync::AnvilGeneric(error) => error.get_documentation(),
            AnvilZksync::AnvilNode(error) => error.get_documentation(),
            AnvilZksync::Halt(error) => error.get_documentation(),
            AnvilZksync::Revert(error) => error.get_documentation(),
            AnvilZksync::StateLoader(error) => error.get_documentation(),
            AnvilZksync::TransactionValidation(error) => error.get_documentation(),
        }
    }
}
impl std::fmt::Display for AnvilZksync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnvilZksync::AnvilEnvironment(component) => component.fmt(f),
            AnvilZksync::AnvilGeneric(component) => component.fmt(f),
            AnvilZksync::AnvilNode(component) => component.fmt(f),
            AnvilZksync::Halt(component) => component.fmt(f),
            AnvilZksync::Revert(component) => component.fmt(f),
            AnvilZksync::StateLoader(component) => component.fmt(f),
            AnvilZksync::TransactionValidation(component) => component.fmt(f),
        }
    }
}
impl std::error::Error for AnvilZksync {}
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    EnumDiscriminants,
    Eq,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(CompilerCode))]
#[strum_discriminants(derive(serde::Serialize, serde::Deserialize, FromRepr))]
#[strum_discriminants(vis(pub))]
pub enum Compiler {
    LLVM_EVM(LLVM_EVM),
    LLVM_Era(LLVM_Era),
    Solc(Solc),
    SolcFork(SolcFork),
    Zksolc(Zksolc),
    Zkvyper(Zkvyper),
}
impl Compiler {
    pub fn get_name(&self) -> &str {
        self.as_ref()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for LLVM_EVM {
    fn to_unified(&self) -> ZksyncError {
        Compiler::LLVM_EVM(self.clone()).to_unified()
    }
}
impl From<LLVM_EVM> for Compiler {
    fn from(val: LLVM_EVM) -> Self {
        Compiler::LLVM_EVM(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for LLVM_Era {
    fn to_unified(&self) -> ZksyncError {
        Compiler::LLVM_Era(self.clone()).to_unified()
    }
}
impl From<LLVM_Era> for Compiler {
    fn from(val: LLVM_Era) -> Self {
        Compiler::LLVM_Era(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Solc {
    fn to_unified(&self) -> ZksyncError {
        Compiler::Solc(self.clone()).to_unified()
    }
}
impl From<Solc> for Compiler {
    fn from(val: Solc) -> Self {
        Compiler::Solc(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for SolcFork {
    fn to_unified(&self) -> ZksyncError {
        Compiler::SolcFork(self.clone()).to_unified()
    }
}
impl From<SolcFork> for Compiler {
    fn from(val: SolcFork) -> Self {
        Compiler::SolcFork(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Zksolc {
    fn to_unified(&self) -> ZksyncError {
        Compiler::Zksolc(self.clone()).to_unified()
    }
}
impl From<Zksolc> for Compiler {
    fn from(val: Zksolc) -> Self {
        Compiler::Zksolc(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Zkvyper {
    fn to_unified(&self) -> ZksyncError {
        Compiler::Zkvyper(self.clone()).to_unified()
    }
}
impl From<Zkvyper> for Compiler {
    fn from(val: Zkvyper) -> Self {
        Compiler::Zkvyper(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Compiler {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Compiler(self.clone())
    }
}
impl From<Compiler> for ZksyncError {
    fn from(value: Compiler) -> Self {
        value.to_unified()
    }
}
impl crate::documentation::Documented for Compiler {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Compiler::LLVM_EVM(error) => error.get_documentation(),
            Compiler::LLVM_Era(error) => error.get_documentation(),
            Compiler::Solc(error) => error.get_documentation(),
            Compiler::SolcFork(error) => error.get_documentation(),
            Compiler::Zksolc(error) => error.get_documentation(),
            Compiler::Zkvyper(error) => error.get_documentation(),
        }
    }
}
impl std::fmt::Display for Compiler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Compiler::LLVM_EVM(component) => component.fmt(f),
            Compiler::LLVM_Era(component) => component.fmt(f),
            Compiler::Solc(component) => component.fmt(f),
            Compiler::SolcFork(component) => component.fmt(f),
            Compiler::Zksolc(component) => component.fmt(f),
            Compiler::Zkvyper(component) => component.fmt(f),
        }
    }
}
impl std::error::Error for Compiler {}
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    EnumDiscriminants,
    Eq,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(CoreCode))]
#[strum_discriminants(derive(serde::Serialize, serde::Deserialize, FromRepr))]
#[strum_discriminants(vis(pub))]
pub enum Core {
    API(API),
    EraVM(EraVM),
    ExecutionPlatform(ExecutionPlatform),
    Sequencer(Sequencer),
}
impl Core {
    pub fn get_name(&self) -> &str {
        self.as_ref()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for API {
    fn to_unified(&self) -> ZksyncError {
        Core::API(self.clone()).to_unified()
    }
}
impl From<API> for Core {
    fn from(val: API) -> Self {
        Core::API(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for EraVM {
    fn to_unified(&self) -> ZksyncError {
        Core::EraVM(self.clone()).to_unified()
    }
}
impl From<EraVM> for Core {
    fn from(val: EraVM) -> Self {
        Core::EraVM(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for ExecutionPlatform {
    fn to_unified(&self) -> ZksyncError {
        Core::ExecutionPlatform(self.clone()).to_unified()
    }
}
impl From<ExecutionPlatform> for Core {
    fn from(val: ExecutionPlatform) -> Self {
        Core::ExecutionPlatform(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Sequencer {
    fn to_unified(&self) -> ZksyncError {
        Core::Sequencer(self.clone()).to_unified()
    }
}
impl From<Sequencer> for Core {
    fn from(val: Sequencer) -> Self {
        Core::Sequencer(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Core {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Core(self.clone())
    }
}
impl From<Core> for ZksyncError {
    fn from(value: Core) -> Self {
        value.to_unified()
    }
}
impl crate::documentation::Documented for Core {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Core::API(error) => error.get_documentation(),
            Core::EraVM(error) => error.get_documentation(),
            Core::ExecutionPlatform(error) => error.get_documentation(),
            Core::Sequencer(error) => error.get_documentation(),
        }
    }
}
impl std::fmt::Display for Core {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Core::API(component) => component.fmt(f),
            Core::EraVM(component) => component.fmt(f),
            Core::ExecutionPlatform(component) => component.fmt(f),
            Core::Sequencer(component) => component.fmt(f),
        }
    }
}
impl std::error::Error for Core {}
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    EnumDiscriminants,
    Eq,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(FoundryCode))]
#[strum_discriminants(derive(serde::Serialize, serde::Deserialize, FromRepr))]
#[strum_discriminants(vis(pub))]
pub enum Foundry {
    FoundryUpstream(FoundryUpstream),
    FoundryZksync(FoundryZksync),
}
impl Foundry {
    pub fn get_name(&self) -> &str {
        self.as_ref()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for FoundryUpstream {
    fn to_unified(&self) -> ZksyncError {
        Foundry::FoundryUpstream(self.clone()).to_unified()
    }
}
impl From<FoundryUpstream> for Foundry {
    fn from(val: FoundryUpstream) -> Self {
        Foundry::FoundryUpstream(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for FoundryZksync {
    fn to_unified(&self) -> ZksyncError {
        Foundry::FoundryZksync(self.clone()).to_unified()
    }
}
impl From<FoundryZksync> for Foundry {
    fn from(val: FoundryZksync) -> Self {
        Foundry::FoundryZksync(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Foundry {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Foundry(self.clone())
    }
}
impl From<Foundry> for ZksyncError {
    fn from(value: Foundry) -> Self {
        value.to_unified()
    }
}
impl crate::documentation::Documented for Foundry {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Foundry::FoundryUpstream(error) => error.get_documentation(),
            Foundry::FoundryZksync(error) => error.get_documentation(),
        }
    }
}
impl std::fmt::Display for Foundry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Foundry::FoundryUpstream(component) => component.fmt(f),
            Foundry::FoundryZksync(component) => component.fmt(f),
        }
    }
}
impl std::error::Error for Foundry {}
#[repr(u32)]
#[derive(
    AsRefStr,
    Clone,
    Debug,
    EnumDiscriminants,
    Eq,
    PartialEq,
    serde :: Serialize,
    serde :: Deserialize,
)]
#[strum_discriminants(name(HardhatCode))]
#[strum_discriminants(derive(serde::Serialize, serde::Deserialize, FromRepr))]
#[strum_discriminants(vis(pub))]
pub enum Hardhat {
    HardhatUpstream(HardhatUpstream),
    HardhatZksync(HardhatZksync),
}
impl Hardhat {
    pub fn get_name(&self) -> &str {
        self.as_ref()
    }
}
impl ICustomError<ZksyncError, ZksyncError> for HardhatUpstream {
    fn to_unified(&self) -> ZksyncError {
        Hardhat::HardhatUpstream(self.clone()).to_unified()
    }
}
impl From<HardhatUpstream> for Hardhat {
    fn from(val: HardhatUpstream) -> Self {
        Hardhat::HardhatUpstream(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for HardhatZksync {
    fn to_unified(&self) -> ZksyncError {
        Hardhat::HardhatZksync(self.clone()).to_unified()
    }
}
impl From<HardhatZksync> for Hardhat {
    fn from(val: HardhatZksync) -> Self {
        Hardhat::HardhatZksync(val)
    }
}
impl ICustomError<ZksyncError, ZksyncError> for Hardhat {
    fn to_unified(&self) -> ZksyncError {
        ZksyncError::Hardhat(self.clone())
    }
}
impl From<Hardhat> for ZksyncError {
    fn from(value: Hardhat) -> Self {
        value.to_unified()
    }
}
impl crate::documentation::Documented for Hardhat {
    type Documentation = &'static zksync_error_description::ErrorDocumentation;
    fn get_documentation(
        &self,
    ) -> Result<Option<Self::Documentation>, crate::documentation::DocumentationError> {
        match self {
            Hardhat::HardhatUpstream(error) => error.get_documentation(),
            Hardhat::HardhatZksync(error) => error.get_documentation(),
        }
    }
}
impl std::fmt::Display for Hardhat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Hardhat::HardhatUpstream(component) => component.fmt(f),
            Hardhat::HardhatZksync(component) => component.fmt(f),
        }
    }
}
impl std::error::Error for Hardhat {}
