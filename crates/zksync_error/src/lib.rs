
//!
//! AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//!

#![allow(unused)]

pub mod error;
pub mod identifier;
pub mod kind;
pub mod packed;
pub mod serialized;
pub mod untyped;
pub mod documentation;


pub use crate::error::domains::ZksyncError;

pub mod anvil {
   pub mod halt {
      pub use crate::error::definitions::Halt as HaltError;
      pub use crate::error::definitions::Halt::ValidationFailed;
      pub use crate::error::definitions::Halt::PaymasterValidationFailed;
      pub use crate::error::definitions::Halt::PrePaymasterPreparationFailed;
      pub use crate::error::definitions::Halt::PayForTxFailed;
      pub use crate::error::definitions::Halt::FailedToMarkFactoryDependencies;
      pub use crate::error::definitions::Halt::FailedToChargeFee;
      pub use crate::error::definitions::Halt::FromIsNotAnAccount;
      pub use crate::error::definitions::Halt::InnerTxError;
      pub use crate::error::definitions::Halt::Unknown;
      pub use crate::error::definitions::Halt::UnexpectedVMBehavior;
      pub use crate::error::definitions::Halt::BootloaderOutOfGas;
      pub use crate::error::definitions::Halt::ValidationOutOfGas;
      pub use crate::error::definitions::Halt::TooBigGasLimit;
      pub use crate::error::definitions::Halt::NotEnoughGasProvided;
      pub use crate::error::definitions::Halt::MissingInvocationLimitReached;
      pub use crate::error::definitions::Halt::FailedToSetL2Block;
      pub use crate::error::definitions::Halt::FailedToAppendTransactionToL2Block;
      pub use crate::error::definitions::Halt::VMPanic;
      pub use crate::error::definitions::Halt::TracerCustom;
      pub use crate::error::definitions::Halt::FailedToPublishCompressedBytecodes;
      pub use crate::error::definitions::Halt::FailedBlockTimestampAssertion;
      pub use crate::error::definitions::Halt::GenericError;
      
      #[macro_export]
      macro_rules! anvil_halt_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::Halt::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::anvil_halt_generic_error as generic_error;
      }
   pub mod revert {
      pub use crate::error::definitions::Revert as RevertError;
      pub use crate::error::definitions::Revert::General;
      pub use crate::error::definitions::Revert::InnerTxError;
      pub use crate::error::definitions::Revert::VmError;
      pub use crate::error::definitions::Revert::Unknown;
      pub use crate::error::definitions::Revert::GenericError;
      
      #[macro_export]
      macro_rules! anvil_revert_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::Revert::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::anvil_revert_generic_error as generic_error;
      }
   }
pub mod compiler {
   pub mod llvm_evm {
      pub use crate::error::definitions::LLVM_EVM as LLVM_EVMError;
      pub use crate::error::definitions::LLVM_EVM::GenericError;
      
      #[macro_export]
      macro_rules! compiler_llvm_evm_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::LLVM_EVM::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::compiler_llvm_evm_generic_error as generic_error;
      }
   pub mod llvm_era {
      pub use crate::error::definitions::LLVM_Era as LLVM_EraError;
      pub use crate::error::definitions::LLVM_Era::GenericError;
      
      #[macro_export]
      macro_rules! compiler_llvm_era_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::LLVM_Era::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::compiler_llvm_era_generic_error as generic_error;
      }
   pub mod solc {
      pub use crate::error::definitions::Solc as SolcError;
      pub use crate::error::definitions::Solc::GenericError;
      
      #[macro_export]
      macro_rules! compiler_solc_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::Solc::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::compiler_solc_generic_error as generic_error;
      }
   pub mod solc_fork {
      pub use crate::error::definitions::SolcFork as SolcForkError;
      pub use crate::error::definitions::SolcFork::GenericError;
      
      #[macro_export]
      macro_rules! compiler_solc_fork_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::SolcFork::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::compiler_solc_fork_generic_error as generic_error;
      }
   pub mod zksolc {
      pub use crate::error::definitions::Zksolc as ZksolcError;
      pub use crate::error::definitions::Zksolc::GenericError;
      
      #[macro_export]
      macro_rules! compiler_zksolc_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::Zksolc::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::compiler_zksolc_generic_error as generic_error;
      }
   pub mod zkvyper {
      pub use crate::error::definitions::Zkvyper as ZkvyperError;
      pub use crate::error::definitions::Zkvyper::GenericError;
      
      #[macro_export]
      macro_rules! compiler_zkvyper_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::Zkvyper::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::compiler_zkvyper_generic_error as generic_error;
      }
   }
pub mod core {
   pub mod api {
      pub use crate::error::definitions::API as APIError;
      pub use crate::error::definitions::API::GenericError;
      
      #[macro_export]
      macro_rules! core_api_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::API::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::core_api_generic_error as generic_error;
      }
   pub mod eravm {
      pub use crate::error::definitions::EraVM as EraVMError;
      pub use crate::error::definitions::EraVM::GenericError;
      
      #[macro_export]
      macro_rules! core_eravm_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::EraVM::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::core_eravm_generic_error as generic_error;
      }
   pub mod exec {
      pub use crate::error::definitions::ExecutionPlatform as ExecutionPlatformError;
      pub use crate::error::definitions::ExecutionPlatform::GenericError;
      
      #[macro_export]
      macro_rules! core_exec_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::ExecutionPlatform::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::core_exec_generic_error as generic_error;
      }
   pub mod seq {
      pub use crate::error::definitions::Sequencer as SequencerError;
      pub use crate::error::definitions::Sequencer::GenericSequencerError;
      pub use crate::error::definitions::Sequencer::GenericError;
      
      #[macro_export]
      macro_rules! core_seq_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::Sequencer::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::core_seq_generic_error as generic_error;
      }
   }
pub mod foundry {
   pub mod upstream {
      pub use crate::error::definitions::FoundryUpstream as FoundryUpstreamError;
      pub use crate::error::definitions::FoundryUpstream::GenericError;
      
      #[macro_export]
      macro_rules! foundry_upstream_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::FoundryUpstream::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::foundry_upstream_generic_error as generic_error;
      }
   pub mod zksync {
      pub use crate::error::definitions::FoundryZksync as FoundryZksyncError;
      pub use crate::error::definitions::FoundryZksync::GenericError;
      
      #[macro_export]
      macro_rules! foundry_zksync_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::FoundryZksync::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::foundry_zksync_generic_error as generic_error;
      }
   }
pub mod hardhat {
   pub mod upstream {
      pub use crate::error::definitions::HardhatUpstream as HardhatUpstreamError;
      pub use crate::error::definitions::HardhatUpstream::GenericError;
      
      #[macro_export]
      macro_rules! hardhat_upstream_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::HardhatUpstream::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::hardhat_upstream_generic_error as generic_error;
      }
   pub mod zksync {
      pub use crate::error::definitions::HardhatZksync as HardhatZksyncError;
      pub use crate::error::definitions::HardhatZksync::GenericError;
      
      #[macro_export]
      macro_rules! hardhat_zksync_generic_error {
          ($($arg:tt)*) => {
              zksync_error::error::definitions::HardhatZksync::GenericError { message: format!($($arg)*) }
          };
      }
      pub use crate::hardhat_zksync_generic_error as generic_error;
      }
   }
