//!
//! AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//!

#![allow(unused)]
pub mod documentation;
pub mod error;
pub mod identifier;
pub mod kind;
pub mod packed;
pub mod serialized;
pub mod untyped;
pub use crate::error::domains::ZksyncError;
pub mod anvil {
    pub use crate::error::domains::Anvil as AnvilError;
    pub mod env {
        pub use crate::error::definitions::AnvilEnvironment as AnvilEnvironmentError;
        pub use crate::error::definitions::AnvilEnvironment::GenericError;
        #[macro_export]
        macro_rules ! anvil_env_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: AnvilEnvironment :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_env_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> AnvilEnvironmentError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::AnvilError {
            super::AnvilError::AnvilEnvironment(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod gen {
        pub use crate::error::definitions::AnvilGeneric as AnvilGenericError;
        pub use crate::error::definitions::AnvilGeneric::GenericError;
        #[macro_export]
        macro_rules ! anvil_gen_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: AnvilGeneric :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::anvil_gen_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> AnvilGenericError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::AnvilError {
            super::AnvilError::AnvilGeneric(GenericError {
                message: err.to_string(),
            })
        }
    }
}
pub mod compiler {
    pub use crate::error::domains::Compiler as CompilerError;
    pub mod llvm_evm {
        pub use crate::error::definitions::LLVM_EVM as LLVM_EVMError;
        pub use crate::error::definitions::LLVM_EVM::GenericError;
        #[macro_export]
        macro_rules ! compiler_llvm_evm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: LLVM_EVM :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_llvm_evm_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> LLVM_EVMError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::LLVM_EVM(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod llvm_era {
        pub use crate::error::definitions::LLVM_Era as LLVM_EraError;
        pub use crate::error::definitions::LLVM_Era::GenericError;
        #[macro_export]
        macro_rules ! compiler_llvm_era_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: LLVM_Era :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_llvm_era_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> LLVM_EraError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::LLVM_Era(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod solc {
        pub use crate::error::definitions::Solc as SolcError;
        pub use crate::error::definitions::Solc::GenericError;
        #[macro_export]
        macro_rules ! compiler_solc_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: Solc :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_solc_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> SolcError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Solc(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod solc_fork {
        pub use crate::error::definitions::SolcFork as SolcForkError;
        pub use crate::error::definitions::SolcFork::GenericError;
        #[macro_export]
        macro_rules ! compiler_solc_fork_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: SolcFork :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_solc_fork_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> SolcForkError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::SolcFork(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod zksolc {
        pub use crate::error::definitions::Zksolc as ZksolcError;
        pub use crate::error::definitions::Zksolc::GenericError;
        #[macro_export]
        macro_rules ! compiler_zksolc_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: Zksolc :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_zksolc_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> ZksolcError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Zksolc(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod zkvyper {
        pub use crate::error::definitions::Zkvyper as ZkvyperError;
        pub use crate::error::definitions::Zkvyper::GenericError;
        #[macro_export]
        macro_rules ! compiler_zkvyper_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: Zkvyper :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::compiler_zkvyper_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> ZkvyperError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CompilerError {
            super::CompilerError::Zkvyper(GenericError {
                message: err.to_string(),
            })
        }
    }
}
pub mod core {
    pub use crate::error::domains::Core as CoreError;
    pub mod api {
        pub use crate::error::definitions::API as APIError;
        pub use crate::error::definitions::API::GenericError;
        #[macro_export]
        macro_rules ! core_api_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: API :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_api_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> APIError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::API(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod eravm {
        pub use crate::error::definitions::EraVM as EraVMError;
        pub use crate::error::definitions::EraVM::GenericError;
        #[macro_export]
        macro_rules ! core_eravm_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: EraVM :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_eravm_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> EraVMError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::EraVM(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod exec {
        pub use crate::error::definitions::ExecutionPlatform as ExecutionPlatformError;
        pub use crate::error::definitions::ExecutionPlatform::GenericError;
        #[macro_export]
        macro_rules ! core_exec_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: ExecutionPlatform :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_exec_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> ExecutionPlatformError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::ExecutionPlatform(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod seq {
        pub use crate::error::definitions::Sequencer as SequencerError;
        pub use crate::error::definitions::Sequencer::GenericError;
        pub use crate::error::definitions::Sequencer::GenericSequencerError;
        #[macro_export]
        macro_rules ! core_seq_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: Sequencer :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::core_seq_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> SequencerError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::CoreError {
            super::CoreError::Sequencer(GenericError {
                message: err.to_string(),
            })
        }
    }
}
pub mod foundry {
    pub use crate::error::domains::Foundry as FoundryError;
    pub mod upstream {
        pub use crate::error::definitions::FoundryUpstream as FoundryUpstreamError;
        pub use crate::error::definitions::FoundryUpstream::GenericError;
        #[macro_export]
        macro_rules ! foundry_upstream_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: FoundryUpstream :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::foundry_upstream_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> FoundryUpstreamError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::FoundryError {
            super::FoundryError::FoundryUpstream(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod zksync {
        pub use crate::error::definitions::FoundryZksync as FoundryZksyncError;
        pub use crate::error::definitions::FoundryZksync::GenericError;
        #[macro_export]
        macro_rules ! foundry_zksync_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: FoundryZksync :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::foundry_zksync_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> FoundryZksyncError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::FoundryError {
            super::FoundryError::FoundryZksync(GenericError {
                message: err.to_string(),
            })
        }
    }
}
pub mod hardhat {
    pub use crate::error::domains::Hardhat as HardhatError;
    pub mod upstream {
        pub use crate::error::definitions::HardhatUpstream as HardhatUpstreamError;
        pub use crate::error::definitions::HardhatUpstream::GenericError;
        #[macro_export]
        macro_rules ! hardhat_upstream_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: HardhatUpstream :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::hardhat_upstream_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> HardhatUpstreamError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::HardhatError {
            super::HardhatError::HardhatUpstream(GenericError {
                message: err.to_string(),
            })
        }
    }
    pub mod zksync {
        pub use crate::error::definitions::HardhatZksync as HardhatZksyncError;
        pub use crate::error::definitions::HardhatZksync::GenericError;
        #[macro_export]
        macro_rules ! hardhat_zksync_generic_error { ($ ($ arg : tt) *) => { zksync_error :: error :: definitions :: HardhatZksync :: GenericError { message : format ! ($ ($ arg) *) } } ; }
        pub use crate::hardhat_zksync_generic_error as generic_error;
        pub fn to_generic<T: std::fmt::Display>(err: T) -> HardhatZksyncError {
            GenericError {
                message: err.to_string(),
            }
        }
        pub fn to_domain<T: std::fmt::Display>(err: T) -> super::HardhatError {
            super::HardhatError::HardhatZksync(GenericError {
                message: err.to_string(),
            })
        }
    }
}
