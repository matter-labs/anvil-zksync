use alloy::consensus::Transaction;
use alloy::hex::FromHex;
use alloy::network::{ReceiptResponse, TransactionBuilder};
use alloy::primitives::{Bytes, B256, U256};
use alloy::providers::{DynProvider, Provider, WalletProvider};
use alloy::rpc::types::{Filter, Log};
use alloy::sol_types::SolEvent;
use alloy_zksync::network::receipt_response::ReceiptResponse as ZkReceiptResponse;
use alloy_zksync::network::transaction_request::TransactionRequest as ZkTransactionRequest;
use alloy_zksync::network::transaction_response::TransactionResponse as ZkTransactionResponse;
use alloy_zksync::provider::{DepositRequest, ZksyncProvider, ZksyncProviderWithWallet};
use alloy_zksync::utils::ETHER_L1_ADDRESS;
use anvil_zksync_e2e_tests::contracts::{
    BlockExecution, Bridgehub, L1AssetRouter, L1Messenger, L2BaseToken, L2Message,
};
use anvil_zksync_e2e_tests::test_contracts::Counter;
use anvil_zksync_e2e_tests::{AnvilZKsyncApi, AnvilZksyncTesterBuilder, ReceiptExt};
use anyhow::Context;
use std::convert::identity;
use std::time::Duration;
use test_casing::{cases, test_casing, TestCases};

const SUPPORTED_PROTOCOL_VERSIONS: TestCases<u16> = cases! {
    [26, 27, 28]
};

#[test_casing(3, SUPPORTED_PROTOCOL_VERSIONS)]
#[tokio::test]
async fn commit_batch_to_l1(protocol_version: u16) -> anyhow::Result<()> {
    let tester = AnvilZksyncTesterBuilder::default()
        .with_l1()
        .with_node_fn(&|node| node.args(["--protocol-version", &protocol_version.to_string()]))
        .build()
        .await?;

    // Pre-generate a few batches for the rest of the test
    for _ in 0..5 {
        tester.tx().finalize().await?.assert_successful()?;
    }

    // Committing first batch after genesis should work
    let tx_hash = tester.l2_provider().anvil_commit_batch(1).await?;
    let receipt = tester
        .l1_provider()
        .get_transaction_receipt(tx_hash)
        .await?
        .expect("receipt not found on L1");
    assert!(receipt.status());

    // Committing same batch twice shouldn't work
    let error = tester
        .l2_provider()
        .anvil_commit_batch(1)
        .await
        .expect_err("commit batch expected to fail");
    assert!(error.to_string().contains("commit transaction failed"));

    // Next batch is committable
    let tx_hash = tester.l2_provider().anvil_commit_batch(2).await?;
    let receipt = tester
        .l1_provider()
        .get_transaction_receipt(tx_hash)
        .await?
        .expect("receipt not found on L1");
    assert!(receipt.status());

    // Skipping a batch shouldn't work
    let error = tester
        .l2_provider()
        .anvil_commit_batch(4)
        .await
        .expect_err("commit batch expected to fail");
    assert!(error.to_string().contains("commit transaction failed"));

    Ok(())
}

#[test_casing(3, SUPPORTED_PROTOCOL_VERSIONS)]
#[tokio::test]
async fn prove_batch_on_l1(protocol_version: u16) -> anyhow::Result<()> {
    let tester = AnvilZksyncTesterBuilder::default()
        .with_l1()
        .with_node_fn(&|node| node.args(["--protocol-version", &protocol_version.to_string()]))
        .build()
        .await?;

    // Pre-generate a few batches for the rest of the test
    for _ in 0..5 {
        tester.tx().finalize().await?.assert_successful()?;
    }

    // Proving batch without committing shouldn't work
    let error = tester
        .l2_provider()
        .anvil_prove_batch(1)
        .await
        .expect_err("prove batch expected to fail");
    assert!(error.to_string().contains("prove transaction failed"));

    // Commit & prove first batch after genesis
    tester.l2_provider().anvil_commit_batch(1).await?;
    let tx_hash = tester.l2_provider().anvil_prove_batch(1).await?;
    let receipt = tester
        .l1_provider()
        .get_transaction_receipt(tx_hash)
        .await?
        .expect("receipt not found on L1");
    assert!(receipt.status());

    // Proving same batch twice shouldn't work
    let error = tester
        .l2_provider()
        .anvil_prove_batch(1)
        .await
        .expect_err("prove batch expected to fail");
    assert!(error.to_string().contains("prove transaction failed"));

    // Commit & prove next batch
    tester.l2_provider().anvil_commit_batch(2).await?;
    let tx_hash = tester.l2_provider().anvil_prove_batch(2).await?;
    let receipt = tester
        .l1_provider()
        .get_transaction_receipt(tx_hash)
        .await?
        .expect("receipt not found on L1");
    assert!(receipt.status());

    // Skipping a batch shouldn't work
    let error = tester
        .l2_provider()
        .anvil_prove_batch(4)
        .await
        .expect_err("prove batch expected to fail");
    assert!(error.to_string().contains("prove transaction failed"));

    Ok(())
}

#[test_casing(3, SUPPORTED_PROTOCOL_VERSIONS)]
#[tokio::test]
async fn execute_batch_on_l1(protocol_version: u16) -> anyhow::Result<()> {
    let tester = AnvilZksyncTesterBuilder::default()
        .with_l1()
        .with_node_fn(&|node| node.args(["--protocol-version", &protocol_version.to_string()]))
        .build()
        .await?;

    // Pre-generate a few batches for the rest of the test
    for _ in 0..5 {
        tester.tx().finalize().await?.assert_successful()?;
    }

    // Executing batch without committing shouldn't work
    let error = tester
        .l2_provider()
        .anvil_execute_batch(1)
        .await
        .expect_err("execute batch expected to fail");
    assert!(error.to_string().contains("execute transaction failed"));

    // Committing is not enough for executing
    tester.l2_provider().anvil_commit_batch(1).await?;
    let error = tester
        .l2_provider()
        .anvil_execute_batch(1)
        .await
        .expect_err("execute batch expected to fail");
    assert!(error.to_string().contains("execute transaction failed"));

    // Prove & commit first batch after genesis
    tester.l2_provider().anvil_prove_batch(1).await?;
    let tx_hash = tester.l2_provider().anvil_execute_batch(1).await?;
    let receipt = tester
        .l1_provider()
        .get_transaction_receipt(tx_hash)
        .await?
        .expect("receipt not found on L1");
    assert!(receipt.status());

    // Executing same batch twice shouldn't work
    let error = tester
        .l2_provider()
        .anvil_execute_batch(1)
        .await
        .expect_err("execute batch expected to fail");
    assert!(error.to_string().contains("execute transaction failed"));

    // Commit & prove & execute next batch
    tester.l2_provider().anvil_commit_batch(2).await?;
    tester.l2_provider().anvil_prove_batch(2).await?;
    let tx_hash = tester.l2_provider().anvil_execute_batch(2).await?;
    let receipt = tester
        .l1_provider()
        .get_transaction_receipt(tx_hash)
        .await?
        .expect("receipt not found on L1");
    assert!(receipt.status());

    // Skipping a batch shouldn't work
    let error = tester
        .l2_provider()
        .anvil_execute_batch(4)
        .await
        .expect_err("execute batch expected to fail");
    assert!(error.to_string().contains("execute transaction failed"));

    Ok(())
}

#[test_casing(3, SUPPORTED_PROTOCOL_VERSIONS)]
#[tokio::test]
async fn send_l2_to_l1_message(protocol_version: u16) -> anyhow::Result<()> {
    let tester = AnvilZksyncTesterBuilder::default()
        .with_l1()
        .with_node_fn(&|node| node.args(["--protocol-version", &protocol_version.to_string()]))
        .build()
        .await?;

    let message = "Some L2->L1 message";
    let l1_messenger = L1Messenger::new(tester.l2_provider().clone());
    let msg_tx_receipt: ZkReceiptResponse = l1_messenger
        .send_to_l1(message)
        .send()
        .await?
        .get_receipt()
        .await?;
    assert_eq!(
        msg_tx_receipt.l2_to_l1_logs().len(),
        1,
        "expected exactly one L2-to-L1 user log"
    );
    let log = &msg_tx_receipt.l2_to_l1_logs()[0];
    assert_eq!(&log.sender, l1_messenger.address());

    let bridgehub = Bridgehub::new(tester.l1_provider(), tester.l2_provider()).await?;
    let log_batch_number: u64 = msg_tx_receipt
        .l1_batch_number()
        .context("missing L1 batch number")?
        .try_into()?;
    let msg_proof = tester
        .l2_provider()
        .get_l2_to_l1_log_proof(
            msg_tx_receipt.transaction_hash(),
            Some(log.log_index.try_into()?),
        )
        .await?
        .unwrap();
    let l2_message = L2Message {
        txNumberInBatch: msg_tx_receipt
            .l1_batch_tx_index()
            .context("missing L1 batch tx index")?
            .try_into()?,
        sender: tester.l2_provider().default_signer_address(),
        data: message.into(),
    };
    let prove_inclusion_call = bridgehub.prove_l2_message_inclusion(
        log_batch_number,
        msg_proof.id,
        l2_message.clone(),
        msg_proof.proof,
    );

    // Inclusion check fails as the batch has not been executed yet
    assert!(prove_inclusion_call.call().await.is_err());

    // Execute all batches up to the one including the log
    for batch_number in 1..=log_batch_number {
        tester
            .l2_provider()
            .anvil_commit_batch(batch_number)
            .await?;
        tester.l2_provider().anvil_prove_batch(batch_number).await?;
        tester
            .l2_provider()
            .anvil_execute_batch(batch_number)
            .await?;
    }

    // Inclusion check succeeds as the batch has been executed
    let (is_included,) = prove_inclusion_call.call().await?.into();
    assert!(is_included);

    // Inclusion check with fake proof fails
    let fake_prove_inclusion_call = bridgehub.prove_l2_message_inclusion(
        log_batch_number,
        msg_proof.id,
        l2_message,
        vec![B256::random()],
    );
    let (is_included,) = fake_prove_inclusion_call.call().await?.into();
    assert!(!is_included);

    Ok(())
}

#[test_casing(3, SUPPORTED_PROTOCOL_VERSIONS)]
#[tokio::test]
async fn l1_priority_tx(protocol_version: u16) -> anyhow::Result<()> {
    let tester = AnvilZksyncTesterBuilder::default()
        .with_l1()
        .with_node_fn(&|node| node.args(["--protocol-version", &protocol_version.to_string()]))
        .build()
        .await?;

    // Deploy `Counter` contract and validate that it is initialized with `0`
    let counter = Counter::deploy(tester.l2_provider().clone()).await?;
    assert_eq!(counter.get().await?, U256::from(0));

    // Prepare a transaction from a rich account that will increment `Counter` by 1
    let alice = tester.l2_provider().default_signer_address();
    let eip1559_est = tester.l1_provider().estimate_eip1559_fees().await?;
    let tx = counter
        .increment(1)
        .into_transaction_request()
        .with_from(alice)
        .with_max_fee_per_gas(eip1559_est.max_fee_per_gas);

    // But submit it as an L1 transaction through Bridgehub
    let bridgehub = Bridgehub::new(tester.l1_provider().clone(), tester.l2_provider()).await?;
    bridgehub
        .request_execute(tester.l2_provider(), tx.clone())
        .await?
        .watch()
        .await?;
    // Validate that the counter was increased
    assert_eq!(counter.get().await?, U256::from(1));

    Ok(())
}

#[test_casing(3, SUPPORTED_PROTOCOL_VERSIONS)]
#[tokio::test]
async fn deposit(protocol_version: u16) -> anyhow::Result<()> {
    let tester = AnvilZksyncTesterBuilder::default()
        .with_l1()
        .with_node_fn(&|node| node.args(["--protocol-version", &protocol_version.to_string()]))
        .build()
        .await?;

    let alice = tester.l2_provider().default_signer_address();
    let alice_l1_initial_balance = tester.l1_provider().get_balance(alice).await?;
    let alice_l2_initial_balance = tester.l2_provider().get_balance(alice).await?;
    let amount = U256::from(1);

    let deposit_l1_receipt = tester
        .l2_provider()
        .deposit(
            &DepositRequest::new(amount)
                .with_receiver(alice)
                .with_token(ETHER_L1_ADDRESS),
            &tester.l1_provider(),
        )
        .await?;
    deposit_l1_receipt.get_l2_tx()?.get_receipt().await?;
    let deposit_l1_receipt = deposit_l1_receipt.get_receipt();
    let fee =
        U256::from(deposit_l1_receipt.effective_gas_price * deposit_l1_receipt.gas_used as u128);

    let alice_l1_final_balance = tester.l1_provider().get_balance(alice).await?;
    let alice_l2_final_balance = tester.l2_provider().get_balance(alice).await?;
    // Non-strict equality because somehow we spend more than expected and also more than expected
    // gets deposited to L2. Assuming this is expected as zksync-era e2e tests assert the same behavior.
    assert!(alice_l1_final_balance <= alice_l1_initial_balance - fee - amount);
    assert!(alice_l2_final_balance >= alice_l2_initial_balance + amount);

    Ok(())
}

#[test_casing(3, SUPPORTED_PROTOCOL_VERSIONS)]
#[tokio::test]
async fn withdraw(protocol_version: u16) -> anyhow::Result<()> {
    let tester = AnvilZksyncTesterBuilder::default()
        .with_l1()
        .with_node_fn(&|node| node.args(["--protocol-version", &protocol_version.to_string()]))
        .build()
        .await?;

    let alice = tester.l2_provider().default_signer_address();
    let alice_l1_initial_balance = tester.l1_provider().get_balance(alice).await?;
    let alice_l2_initial_balance = tester.l2_provider().get_balance(alice).await?;
    let amount = U256::from(1);

    let l2_base_token = L2BaseToken::new(tester.l2_provider().clone());
    let withdrawal_l2_receipt = l2_base_token.withdraw(alice, amount).await?;
    let l2_fee = U256::from(
        withdrawal_l2_receipt.effective_gas_price() * withdrawal_l2_receipt.gas_used() as u128,
    );

    // Execute all batches up to the one including the log
    let withdrawal_batch_number: u64 = withdrawal_l2_receipt
        .l1_batch_number()
        .context("missing L1 batch number")?
        .try_into()?;
    for batch_number in 1..=withdrawal_batch_number {
        tester
            .l2_provider()
            .anvil_commit_batch(batch_number)
            .await?;
        tester.l2_provider().anvil_prove_batch(batch_number).await?;
        tester
            .l2_provider()
            .anvil_execute_batch(batch_number)
            .await?;
    }

    let l1_asset_router = L1AssetRouter::new(
        tester.l1_provider(),
        DynProvider::new(tester.l2_provider().clone()),
    )
    .await;
    let l1_nullifier = l1_asset_router.l1_nullifier().await?;
    let finalize_withdrawal_l1_receipt = l1_nullifier
        .finalize_withdrawal(withdrawal_l2_receipt)
        .await?;
    let l1_fee = U256::from(
        finalize_withdrawal_l1_receipt.effective_gas_price()
            * finalize_withdrawal_l1_receipt.gas_used() as u128,
    );

    let alice_l1_final_balance = tester.l1_provider().get_balance(alice).await?;
    let alice_l2_final_balance = tester.l2_provider().get_balance(alice).await?;
    assert_eq!(
        alice_l1_final_balance,
        alice_l1_initial_balance - l1_fee + amount
    );
    assert_eq!(
        alice_l2_final_balance,
        alice_l2_initial_balance - l2_fee - amount
    );

    Ok(())
}

#[test_casing(3, SUPPORTED_PROTOCOL_VERSIONS)]
#[tokio::test]
async fn auto_execute_batch(protocol_version: u16) -> anyhow::Result<()> {
    let tester = AnvilZksyncTesterBuilder::default()
        .with_l1()
        .with_node_fn(&|node| {
            node.args([
                "--auto-execute-l1",
                "--protocol-version",
                &protocol_version.to_string(),
            ])
        })
        .build()
        .await?;

    let filter = Filter::new().event_signature(BlockExecution::SIGNATURE_HASH);
    let filter_id = tester.l1_provider().new_filter(&filter).await?;

    const BATCHES: usize = 5;

    // Pre-generate a few batches for the rest of the test
    for _ in 0..BATCHES {
        tester.tx().finalize().await?.assert_successful()?;
    }

    const ATTEMPTS: usize = 10;
    let mut logs = Vec::with_capacity(BATCHES);
    for _ in 0..ATTEMPTS {
        let new_logs = tester
            .l1_provider()
            .get_filter_changes::<Log>(filter_id)
            .await?;
        logs.extend(new_logs);
        if logs.len() >= BATCHES {
            return Ok(());
        }
        tokio::time::sleep(Duration::from_millis(500)).await;
    }
    anyhow::bail!("failed to produce {BATCHES} batches in time, logs: {logs:?}")
}

#[tokio::test]
async fn l1_gas_estimation() -> anyhow::Result<()> {
    async fn test(
        f: impl FnOnce(ZkTransactionRequest) -> ZkTransactionRequest,
    ) -> anyhow::Result<(ZkTransactionResponse, ZkReceiptResponse)> {
        let tester = AnvilZksyncTesterBuilder::default()
            .with_l1()
            .with_node_fn(&|node| {
                node.args(["--protocol-version", "27", "--log", "debug", "-vvvvv"])
            })
            .build()
            .await?;

        // Deploy https://genlayer-testnet.explorer.caldera.xyz/address/0xb20130e34FC8890C85b2929E75aFbb3Ec4064800 locally
        let bytecode = hex::decode("00060000000000020000008003000039000000400030043f0000000100200190000000670000c13d0000006002100270000000d203200197000000040030008c0000017b0000413d000000000201043b000000e002200270000000d50020009c000000760000a13d000000d60020009c000000890000213d000000e20020009c000000af0000213d000000e80020009c000000ef0000213d000000eb0020009c000001860000613d000000ec0020009c0000017b0000c13d000000440030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d000000000200041a0000000103000039000000000403041a0000000405100370000000000505043b0000002401100370000000000101043b000000000015004b0000000006000019000000640000813d00000004070000390000000006000019000000000845004b0000000009030019000000310000613d000002a80000413d000000000002004b000002bf0000613d00000000082800d9000000010980003a000002a80000613d00000000082900a9000000000a9800d900000000002a004b000002a80000c13d000000000048001a000002a80000413d0000000008480019000000000a07041a000000000018004b0000003e0000413d0000000008510049000000000028004b000000470000c13d00000000009a004b000002b90000a13d000000000070043f000001180890009a000000000908041a0000000008020019000000000069001a000002a80000413d0000005e0000013d00000000009a004b000002b90000a13d000000000070043f000001180990009a000000000a09041a0000011909a000d100000000000a004b000000520000613d000000000aa900d90000011900a0009c000002a80000c13d000000000002004b000002bf0000613d000000000b2900d9000000000a8b00a9000000000092004b0000005b0000213d0000000009ba00d9000000000089004b000002a80000c13d0000011909a0012a000000000069001a000002a80000413d000000000058001a000002a80000413d00000000066900190000000005580019000000000015004b000000280000413d000000800060043f0000011601000041000003460001042e0000000001000416000000000001004b000002a60000c13d0000001e01000039000000000010041b0000000201000039000000000001041b000000d3010000410000000302000039000000000012041b000000200100003900000100001004430000012000000443000000d401000041000003460001042e000000ed0020009c000000960000a13d000000ee0020009c000000bc0000213d000000f40020009c000000fa0000213d000000f70020009c000000b50000613d000000f80020009c0000017b0000c13d000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000301043b0000000501000039000000a60000013d000000d70020009c000000d70000213d000000dd0020009c000001070000213d000000e00020009c0000017d0000613d000000e10020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d0000000a01000039000002310000013d000000f90020009c000000e40000a13d000000fa0020009c000001120000213d000000fd0020009c000001d90000613d000000fe0020009c0000017b0000c13d000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000301043b0000000601000039000000000201041a000000000023004b000002a60000813d000000000010043f0000000001000019000600000003001d0345032a0000040f0000000601100029000002310000013d000000e30020009c0000011d0000213d000000e60020009c000001f10000613d000000e70020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d000003e801000039000000800010043f0000011601000041000003460001042e000000ef0020009c000001260000213d000000f20020009c000001f80000613d000000f30020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d0000000901000039000000000001041b0000000201000039000000000001041b000000d3010000410000000302000039000000000012041b0000000401000039000000000201041a000000000002004b0000017b0000613d000000000010043f000001210320009a000000000003041b000000010220008c000000000021041b000000d10000c13d0000017b0000013d000000d80020009c000001310000213d000000db0020009c000001ff0000613d000000dc0020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d0000010801000041000000800010043f0000011601000041000003460001042e000000ff0020009c000002890000613d000001000020009c000002910000613d000001010020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d0000000301000039000002310000013d000000e90020009c000002040000613d000000ea0020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d000000000100041a000000800010043f0000011601000041000003460001042e000000f50020009c0000020b0000613d000000f60020009c0000017b0000c13d000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000301043b0000000701000039000002990000013d000000de0020009c000002150000613d000000df0020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d000005b401000039000000800010043f0000011601000041000003460001042e000000fb0020009c000002260000613d000000fc0020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d0000800a01000039000000800010043f0000011601000041000003460001042e000000e40020009c0000022d0000613d000000e50020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d0000000101000039000002310000013d000000f00020009c0000017d0000613d000000f10020009c0000017b0000c13d0000000001000416000000000001004b000002a60000c13d0000011f01000041000000800010043f0000011601000041000003460001042e000000d90020009c000002350000613d000000da0020009c0000017b0000c13d000000240030008c000002a60000413d0000000202000039000000000402041a0000000401100370000000000101043b000100000001001d000000000041004b000002ae0000a13d0000000301000039000000000501041a00000004060000390000000007000019000005b20040008c000000010440003900000104014000d1000001050110009a00000106011001970000016d0210011a000001070200204100000000015200a9000000000005004b0000014f0000613d00000000035100d9000000000023004b000002a80000c13d000001080110012a000000000051001a000002a80000413d000000000071001a000002a80000413d000000000206041a000001090020009c000002b30000213d000300000001001d000400000007001d000500000005001d000600000004001d000200000002001d0000000101200039000000000016041b000000000060043f0000000001000414000000d20010009c000000d201008041000000c0011002100000010a011001c70000801002000039034503400000040f0000000100200190000002a60000613d000000030200002900000005052000290000000407200029000000000101043b0000000201100029000000000021041b0000000604000029000000010040006c0000000406000039000001420000413d0000000301000039000000000051041b00000002010000390000000102000029000000000021041b0000010b0170012a0000000002000416000000000021004b000002c50000c13d0000000001000019000003460001042e000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000101043b034503090000040f000001ea0000013d000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000101043b000100000001001d000000800010043f0000000001000414000000d20010009c000000d201008041000000c0011002100000011c011001c70000800d0200003900000001030000390000011d040000410345033b0000040f0000000100200190000002a60000613d0000000302000039000000000402041a0000000203000039000000000503041a000000010050006c000001d50000813d0000000406000039000000000700001900000104015000d1000001050110009a00000106011001970000016d0110011a000005b30050008c000001070100204100000000024100a9000000000004004b000001ae0000613d00000000034200d9000000000013004b000002a80000c13d000001080120012a000000000041001a000002a80000413d000000000071001a000002a80000413d000000000206041a0000011e0020009c000002b30000813d000300000001001d000400000007001d000500000005001d000600000004001d000200000002001d0000000101200039000000000016041b000000000060043f0000000001000414000000d20010009c000000d201008041000000c0011002100000010a011001c70000801002000039034503400000040f0000000100200190000002a60000613d000000030200002900000006042000290000000407200029000000000101043b0000000201100029000000000021041b00000005050000290000000105500039000000010050006c0000000406000039000001a20000413d000000010500002900000003020000390000000203000039000000000042041b000000000053041b0000000001000019000003460001042e000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000101043b0000000402000039000000000202041a000000000021004b000002a60000813d034502fb0000040f0000000302200210000000000101041a000000000121022f000000ff0020008c0000000001002019000000400200043d0000000000120435000000d20020009c000000d202008041000000400120021000000120011001c7000003460001042e0000000001000416000000000001004b000002a60000c13d00001f4001000039000000800010043f0000011601000041000003460001042e0000000001000416000000000001004b000002a60000c13d0000012201000041000000800010043f0000011601000041000003460001042e0000000001000416000000000001004b000002a60000c13d0000000201000039000002310000013d0000000001000416000000000001004b000002a60000c13d0000011701000041000000800010043f0000011601000041000003460001042e000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000101043b000000000010041b0000000001000019000003460001042e000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000201043b00001f40012000c9000000000002004b000002220000613d00000000022100d900001f400020008c000002a80000c13d000027100110011a000000800010043f0000011601000041000003460001042e0000000001000416000000000001004b000002a60000c13d0000012301000041000000800010043f0000011601000041000003460001042e0000000001000416000000000001004b000002a60000c13d0000000901000039000000000101041a000000800010043f0000011601000041000003460001042e000000440030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000402100370000000000202043b0000010d0020009c000002a60000213d000600000002001d0000002401100370000000000201043b0000010e01000041000000a00010043f000500000002001d000000a40020043f0000002401000039000000800010043f000000e001000039000000400010043f0000010f0100004100000000001004430000800a0100003900000004001004430000000001000414000000d20010009c000000d201008041000000c00110021000000110011001c70000800202000039034503400000040f0000000100200190000002b20000613d000000000101043b000000000001004b0000000601000029000002a60000613d0000010d01100197000000400600043d00000024026000390000004003000039000000000032043500000111020000410000000000260435000000040260003900000000001204350000004402600039000000800100043d00000000001204350000006402600039000000000001004b000002710000613d00000000030000190000000004230019000000a005300039000000000505043300000000005404350000002003300039000000000013004b0000026a0000413d000000000221001900000000000204350000001f011000390000012402100197000000d20060009c000600000006001d000000d2010000410000000001064019000000400110021000000064052000390000000002000414000000d20020009c000000d202008041000000c0022002100000000503000029000000000003004b000002c90000c13d000000d20050009c000000d2050080410000006003500210000000000113019f000000000112019f0000800a02000039000002d20000013d000000240030008c000002a60000413d0000000401100370000000000101043b0000000102000039000000000012041b0000000001000019000003460001042e000000240030008c000002a60000413d0000000002000416000000000002004b000002a60000c13d0000000401100370000000000301043b0000000801000039000000000201041a000000000023004b000002a60000813d000000000010043f0000000001000019000600000003001d0345032a0000040f0000000601100029000000000101041a0000010d01100197000000800010043f0000011601000041000003460001042e000000000100001900000347000104300000011a01000041000000000010043f0000001101000039000000040010043f0000011b0100004100000347000104300000010201000041000000000010043f00000103010000410000034700010430000000000001042f0000011a01000041000000000010043f0000004101000039000000040010043f0000011b0100004100000347000104300000011a01000041000000000010043f0000003201000039000000040010043f0000011b0100004100000347000104300000011a01000041000000000010043f0000001201000039000000040010043f0000011b0100004100000347000104300000010c01000041000000000010043f000001030100004100000347000104300000006004500210000001120050009c000001130400804100000114011001c70000000001410019000000000121001900008009020000390000800a0400003900000000050000190345033b0000040f00000001002001900000000602000029000002db0000613d00000000010200190000000002000019034503170000040f0000000001000019000003460001042e00000060061002700000001f0460018f0000011505600198000000400200043d0000000003520019000002e70000613d000000000701034f0000000008020019000000007907043c0000000008980436000000000038004b000002e30000c13d000000d206600197000000000004004b000002f50000613d000000000151034f0000000304400210000000000503043300000000054501cf000000000545022f000000000101043b0000010004400089000000000141022f00000000014101cf000000000151019f00000000001304350000006001600210000000d20020009c000000d2020080410000004002200210000000000112019f00000347000104300000000402000039000000000302041a000000000013004b000003030000a13d000000000020043f000001180110009a0000000002000019000000000001042d0000011a01000041000000000010043f0000003201000039000000040010043f0000011b010000410000034700010430000003e8021000c9000000000001004b0000030f0000613d00000000011200d9000003e80010008c000003110000c13d000027100120011a000000000001042d0000011a01000041000000000010043f0000001101000039000000040010043f0000011b0100004100000347000104300000001f0220003900000124022001970000000001120019000000000021004b00000000020000390000000102004039000001090010009c000003230000213d0000000100200190000003230000c13d000000400010043f000000000001042d0000011a01000041000000000010043f0000004101000039000000040010043f0000011b010000410000034700010430000000000001042f0000000002000414000000d20020009c000000d202008041000000c002200210000000d20010009c000000d2010080410000004001100210000000000121019f0000010a011001c70000801002000039034503400000040f0000000100200190000003390000613d000000000101043b000000000001042d000000000100001900000347000104300000033e002104210000000102000039000000000001042d0000000002000019000000000001042d00000343002104230000000102000039000000000001042d0000000002000019000000000001042d0000034500000432000003460001042e000003470001043000000000000000000000000000000000000000000000000000000000ffffffff00000000000000000000000000000000000000000d92289838d21a9968000000000000020000000000000000000000000000004000000100000000000000000000000000000000000000000000000000000000000000000000000000785b8af900000000000000000000000000000000000000000000000000000000ae730b8300000000000000000000000000000000000000000000000000000000c0a604ac00000000000000000000000000000000000000000000000000000000c368c36900000000000000000000000000000000000000000000000000000000c368c36a00000000000000000000000000000000000000000000000000000000de8d9d3800000000000000000000000000000000000000000000000000000000c0a604ad00000000000000000000000000000000000000000000000000000000c2ee3a0800000000000000000000000000000000000000000000000000000000b624615600000000000000000000000000000000000000000000000000000000b624615700000000000000000000000000000000000000000000000000000000bedaeace00000000000000000000000000000000000000000000000000000000ae730b8400000000000000000000000000000000000000000000000000000000b3f05b97000000000000000000000000000000000000000000000000000000008377259400000000000000000000000000000000000000000000000000000000900cf0ce00000000000000000000000000000000000000000000000000000000900cf0cf00000000000000000000000000000000000000000000000000000000a5b8da4f0000000000000000000000000000000000000000000000000000000083772595000000000000000000000000000000000000000000000000000000008b7e92a6000000000000000000000000000000000000000000000000000000007d472c77000000000000000000000000000000000000000000000000000000007d472c78000000000000000000000000000000000000000000000000000000008119e57c00000000000000000000000000000000000000000000000000000000785b8afa0000000000000000000000000000000000000000000000000000000079e79b7c00000000000000000000000000000000000000000000000000000000217fcc3d000000000000000000000000000000000000000000000000000000004971ec01000000000000000000000000000000000000000000000000000000006d929001000000000000000000000000000000000000000000000000000000006d929002000000000000000000000000000000000000000000000000000000007492100f000000000000000000000000000000000000000000000000000000004971ec02000000000000000000000000000000000000000000000000000000005688670d0000000000000000000000000000000000000000000000000000000038dda3470000000000000000000000000000000000000000000000000000000038dda348000000000000000000000000000000000000000000000000000000003fcc832e00000000000000000000000000000000000000000000000000000000217fcc3e0000000000000000000000000000000000000000000000000000000035f307ef0000000000000000000000000000000000000000000000000000000012ba015d000000000000000000000000000000000000000000000000000000001a4c1844000000000000000000000000000000000000000000000000000000001a4c184500000000000000000000000000000000000000000000000000000000210663e40000000000000000000000000000000000000000000000000000000012ba015e000000000000000000000000000000000000000000000000000000001981458d00000000000000000000000000000000000000000000000000000000052adb7b0000000000000000000000000000000000000000000000000000000008360b45000000000000000000000000000000000000000000000000000000000ab07e88719a0d39000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff7d2ea92d17acfffffffffffffffffffffffffffffffffffffffffffffffffc87d25316270000000000000000000000000000000000000000000000000000fffffffffffffffc000000000000000000000000000000000000000000000000000063abafdda4d20000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000ffffffffffffffff0200000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000e8d4a510003c1f1f1600000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffff42966c68000000000000000000000000000000000000000000000000000000001806aa1896bbf26568e884a7374b41e002500962caba6a15023a8d90e8508b83020000020000000000000000000000000000002400000000000000000000000084bc3eb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000ffffffff000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffe00000000000000000000000000000000000000020000000800000000000000000000000000000000000000000000000000000000000000000000000000001518075ca53043ea007e5c65182cbb028f60d7179ff4b55739a3949b401801c942e6500000000000000000000000000000000000000000000000000000000000186a04e487b7100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002400000000000000000000000002000000000000000000000000000000000000200000008000000000000000006bae605e24bc4cb18abe39d95b9d7fcffa36cf0725b4773ff0f2bc41d4f23cf00000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000008e1bc9bf040000000000000000000000000000000000000000002000000000000000000000000075ca53043ea007e5c65182cbb028f60d7179ff4b55739a3949b401801c942e6600000000000000000000000000000000000000000000000003782dace9d90000000000000000000000000000000000000000000000000000000082d156d2e854ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe000000000000000000000000000000000000000000000000000000000000000005d6ed7861fa3945a799b2d1eee5b138045acb020573bc2f943e0109484d71f99").unwrap();
        let deploy_tx =
            ZkTransactionRequest::default().with_create_params(bytecode, vec![], vec![])?;
        let contract_address = tester
            .l2_provider()
            .send_transaction(deploy_tx)
            .await?
            .get_receipt()
            .await?
            .contract_address()
            .expect("Failed to get contract address");

        // Replicate L1 priority transaction https://genlayer-testnet.explorer.caldera.xyz/tx/0x3ef55f45c8ad0580604aaff5371fc669aaef3b518b4b70599bf4c4222fd86aa6
        let alice = tester.l2_provider().default_signer_address();
        let eip1559_est = tester.l1_provider().estimate_eip1559_fees().await?;
        let tx = ZkTransactionRequest::default()
            .with_to(contract_address)
            .with_from(alice)
            .with_max_fee_per_gas(eip1559_est.max_fee_per_gas)
            .with_max_priority_fee_per_gas(0)
            .with_gas_per_pubdata(U256::from(800))
            .with_input(Bytes::from_hex(
                "785b8afa00000000000000000000000000000000000000000000000000000000000001cc",
            )?);
        let tx = f(tx);
        let bridgehub = Bridgehub::new(tester.l1_provider().clone(), tester.l2_provider()).await?;
        let receipt = bridgehub
            .request_execute(tester.l2_provider(), tx)
            .await?
            .get_receipt()
            .await?;
        Ok((
            tester
                .l2_provider()
                .get_transaction_by_hash(receipt.transaction_hash())
                .await?
                .unwrap(),
            receipt,
        ))
    }

    // Test transaction with proper L1->L2 estimation
    // Estimated gas limit is very high but used gas is actually quite low
    let (tx_response, tx_receipt) = test(identity).await?;
    assert!(tx_receipt.status());
    assert_eq!(tx_response.gas_limit(), 25_217_338);
    assert_eq!(tx_receipt.gas_used(), 3_244_732);

    // Create cheaper version of transaction: use progressive multiplier times gas used according to above
    // Note: Explicitly supplying gas limit makes the flow not use `zks_estimateL1ToL2Gas`
    for i in 5..=5 {
        let (cheap_tx_response, cheap_tx_receipt) =
            test(|tx| tx.with_gas_limit(tx_receipt.gas_used() * i)).await?;
        // Validate that cheap tx fails while consuming all provided gas
        assert!(!cheap_tx_receipt.status());
        assert_eq!(cheap_tx_receipt.gas_used(), cheap_tx_response.gas_limit());
    }

    Ok(())
}
